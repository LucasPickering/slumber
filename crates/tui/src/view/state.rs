//! State types for the view.

use derive_more::Deref;
use std::time::Duration;
use uuid::Uuid;

/// A uniquely identified immutable value. Useful for detecting changes in
/// values that are expensive to do full comparisons on (e.g. large blocks of
/// text).
#[derive(Copy, Clone, Debug, Deref)]
pub struct Identified<T> {
    id: Uuid,
    #[deref]
    value: T,
}

impl<T> Identified<T> {
    pub fn new(value: T) -> Self {
        Self {
            id: Uuid::new_v4(),
            value,
        }
    }

    pub fn id(&self) -> Uuid {
        self.id
    }
}

impl<T> Identified<T> {
    /// Map the internal `T` into a `U`, retaining the same ID
    pub fn map<U>(self, f: impl FnOnce(T) -> U) -> Identified<U> {
        Identified {
            id: self.id,
            value: f(self.value),
        }
    }

    /// Map the internal `T` into `&T`, retaining the same ID
    pub fn as_ref(&self) -> Identified<&T> {
        Identified {
            id: self.id,
            value: &self.value,
        }
    }
}

impl<T> From<T> for Identified<T> {
    fn from(value: T) -> Self {
        Self::new(value)
    }
}

/// A notification is an ephemeral informational message generated by some async
/// action. It doesn't grab focus, but will be useful to the user nonetheless.
/// It should be shown for a short period of time, then disappear on its own.
#[derive(Debug)]
pub struct Notification {
    /// Unique ID for this notification. Used to ensure the clear timer is
    /// clearing the correct notification
    pub id: Uuid,
    pub message: String,
}

impl Notification {
    /// Notifications should be cleared automatically after this amount of time
    pub const DURATION: Duration = Duration::from_secs(5);

    pub fn new(message: String) -> Self {
        Self {
            id: Uuid::new_v4(),
            message,
        }
    }
}
