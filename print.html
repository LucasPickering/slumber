<!--
Copied from https://github.com/rust-lang/mdBook/blob/v0.4.43/src/theme/index.hbs
Overridden to remove prev/next page buttons because they're big and useless
-->


<!DOCTYPE HTML>
<html lang="en" class="dark sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Slumber</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Slumber is a TUI (terminal user interface) HTTP client. Define, execute, and share configurable HTTP requests.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "dark";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Slumber</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/LucasPickering/slumber" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Slumber is a terminal-based HTTP client, built for interacting with REST and other HTTP clients. It has two usage modes: Terminal User Interface (TUI) and Command Line Interface (CLI). The TUI is the most useful, and allows for interactively sending requests and viewing responses. The CLI is useful for sending quick requests and scripting.</p>
<p>The goal of Slumber is to be <strong>easy to use, configurable, and sharable</strong>. To that end, configuration is defined in a YAML file called the <strong>request collection</strong>. Both usage modes (TUI and CLI) share the same basic configuration, which is called the <a href="./api/request_collection/index.html">request collection</a>.</p>
<p>Check out the <a href="./getting_started.html">Getting Started guide</a> to try it out, or move onto <a href="./user_guide/key_concepts.html">Key Concepts</a> to start learning in depth about Slumber.</p>
<p><img src="./images/demo.gif" alt="Slumber demo" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install"><a class="header" href="#install">Install</a></h1>
<p>Slumber binaries are available from the <a href="https://github.com/LucasPickering/slumber/releases">GitHub Releases page</a>. Or if you prefer a managed installation:</p>
<h3 id="cargo"><a class="header" href="#cargo">cargo</a></h3>
<pre><code class="language-sh">cargo install slumber --locked
</code></pre>
<h3 id="cargo-binstall"><a class="header" href="#cargo-binstall">cargo binstall</a></h3>
<pre><code class="language-sh">cargo binstall slumber
</code></pre>
<h3 id="homebrew"><a class="header" href="#homebrew">homebrew</a></h3>
<pre><code class="language-sh">brew install LucasPickering/tap/slumber
</code></pre>
<h3 id="sh"><a class="header" href="#sh">sh</a></h3>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -LsSf https://github.com/LucasPickering/slumber/releases/download/v3.3.0/slumber-installer.sh | sh
</code></pre>
<h3 id="powershell"><a class="header" href="#powershell">powershell</a></h3>
<pre><code class="language-sh">powershell -c "irm https://github.com/LucasPickering/slumber/releases/download/v3.3.0/slumber-installer.ps1 | iex"
</code></pre>
<h2 id="shell-completions"><a class="header" href="#shell-completions">Shell Completions</a></h2>
<p>After installation, you can optionally install shell completions for TAB-complete of CLI commands. For the full list of supported shells, <a href="https://docs.rs/clap_complete/latest/clap_complete/aot/enum.Shell.html">see the clap docs</a>.</p>
<blockquote>
<p>Note: Slumber uses clap's native shell completions, which are still experimental. <a href="https://github.com/clap-rs/clap/issues/3166">This issue</a> outlines the remaining work to be done.</p>
</blockquote>
<p>To source your completions:</p>
<h3 id="bash"><a class="header" href="#bash">Bash</a></h3>
<pre><code class="language-sh">echo "source &lt;(COMPLETE=bash slumber)" &gt;&gt; ~/.bashrc
</code></pre>
<h3 id="elvish"><a class="header" href="#elvish">Elvish</a></h3>
<pre><code class="language-sh">echo "eval (E:COMPLETE=elvish slumber | slurp)" &gt;&gt; ~/.elvish/rc.elv
</code></pre>
<h3 id="fish"><a class="header" href="#fish">Fish</a></h3>
<pre><code class="language-sh">echo "source (COMPLETE=fish slumber | psub)" &gt;&gt; ~/.config/fish/config.fish
</code></pre>
<h3 id="powershell-1"><a class="header" href="#powershell-1">Powershell</a></h3>
<pre><code class="language-sh">echo "COMPLETE=powershell slumber | Invoke-Expression" &gt;&gt; $PROFILE
</code></pre>
<h3 id="zsh"><a class="header" href="#zsh">Zsh</a></h3>
<pre><code class="language-sh">echo "source &lt;(COMPLETE=zsh slumber)" &gt;&gt; ~/.zshrc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>Once you've <a href="/install.html">installed Slumber</a>, setup is easy.</p>
<h3 id="1-create-a-slumber-collection-file"><a class="header" href="#1-create-a-slumber-collection-file">1. Create a Slumber collection file</a></h3>
<p>Slumber's core feature is that it's <strong>source-based</strong>. That means you write down your configuration in a file first, then run Slumber and it reads the file. This differs from other popular clients such as Postman and Insomnia, where you define your configuration in the app, and it saves it to a file for you. The goal of being source-based is to make it easy to save and share your configurations.</p>
<p>The easiest way to get started is to generate a new collection with the <code>new</code> subcommand:</p>
<pre><code class="language-sh">slumber new
</code></pre>
<h3 id="2-run-slumber"><a class="header" href="#2-run-slumber">2. Run Slumber</a></h3>
<pre><code class="language-sh">slumber
</code></pre>
<p>This will start the TUI, and you'll see the example requests available. Use tab/shift+tab (or the shortcut keys shown in the pane headers) to navigate around. Select a recipe in the left pane, then hit Enter to send a request.</p>
<h2 id="going-further"><a class="header" href="#going-further">Going Further</a></h2>
<p>Now that you have a collection, you'll want to customize it. Here's another example of a simple collection, showcasing multiple profiles:</p>
<pre><code class="language-yaml"># slumber.yml
profiles:
  local:
    data:
      host: http://localhost:5000
  production:
    data:
      host: https://myfishes.fish

requests:
  create_fish:
    method: POST
    url: "{{ host }}/fishes"
    body:
      type: json
      data: { "kind": "barracuda", "name": "Jimmy" }

  list_fish:
    method: GET
    url: "{{ host }}/fishes"
    query:
      big: true
</code></pre>
<p>This request collection uses <a href="./user_guide/templates/index.html">templates</a> and <a href="./user_guide/profiles.html">profiles</a>, allowing you to dynamically change the target host.</p>
<p>To learn more about the powerful features of Slumber you can use in your collections, keep reading with <a href="./user_guide/key_concepts.html">Key Concepts</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h1>
<p>There are a handful of key concepts you need to understand how to effectively configure and use Slumber. You can read about each one in detail on its linked API reference page.</p>
<h2 id="request-collection"><a class="header" href="#request-collection"><a href="user_guide/../api/request_collection/index.html">Request Collection</a></a></h2>
<p>The collection is the main form of configuration. It defines a set of request recipes, which enable Slumber to make requests to your API.</p>
<h2 id="request-recipe"><a class="header" href="#request-recipe"><a href="user_guide/../api/request_collection/request_recipe.html">Request Recipe</a></a></h2>
<p>A recipe defines which HTTP requests Slumber can make. A recipe generally corresponds to one endpoint on an API, although you can create as many recipes per endpoint as you'd like.</p>
<h2 id="profile"><a class="header" href="#profile"><a href="user_guide/./profiles.html">Profile</a></a></h2>
<p>A profile is a set of static template values. A collection can contain a list of profiles, allowing you to quickly switch between different sets of values. This is useful for using different deployment environments, different sets of IDs, etc.</p>
<h2 id="template"><a class="header" href="#template"><a href="user_guide/./templates/index.html">Template</a></a></h2>
<p>Templates are Slumber's most powerful feature. They allow you to dynamically build URLs, query parameters, request bodies, etc. using predefined <em>or</em> dynamic values.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipes"><a class="header" href="#recipes">Recipes</a></h1>
<p>Recipes are the core feature of Slumber; they define how to generate HTTP requests. The terms "recipe" and "request" are often used interchangeably by users, but there is a technical distinction:</p>
<ul>
<li>A recipe is a definition for how to generate any number of requests</li>
<li>A request is a single chunk of data (URL+headers+body) to send to a server</li>
</ul>
<p>The distinction isn't that important; generally it's easy to figure out what "request" means based on the context. This is exactly why Slumber uses a <code>requests</code> field in the collection file instead of <code>recipes</code>. It's easy to guess and easy to remember.</p>
<h2 id="method--url"><a class="header" href="#method--url">Method &amp; URL</a></h2>
<p>A recipe's <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods">HTTP method</a> is defined by the <code>method</code> field. Unlike other recipe fields, <code>method</code> is <strong>not</strong> a template. It must be a static string containing one of the supported methods (case insensitive):</p>
<ul>
<li><code>CONNECT</code></li>
<li><code>DELETE</code></li>
<li><code>GET</code></li>
<li><code>HEAD</code></li>
<li><code>OPTIONS</code></li>
<li><code>PATCH</code></li>
<li><code>POST</code></li>
<li><code>PUT</code></li>
<li><code>TRACE</code></li>
</ul>
<p>The recipe URL is defined by the <code>url</code> field:</p>
<pre><code class="language-yaml">requests:
  get_fishes:
    method: GET
    url: "https://myfishes.fish/fishes"
</code></pre>
<h2 id="query-parameters"><a class="header" href="#query-parameters">Query Parameters</a></h2>
<blockquote>
<p>See the <a href="user_guide/../api/request_collection/query_parameters.html">API docs</a> for more detailed info.</p>
</blockquote>
<p>Query parameters are specified via the <code>query</code> field. They form a component of a request URL and provide additional information to the server about a request. In a request recipe, query parameters are defined as a map of <code>parameter: value</code>. The value can be a singular value (string/boolean/etc.) or a list of values.</p>
<pre><code class="language-yaml">recipes:
  get_fishes:
    method: GET
    url: "https://myfishes.fish/fishes"
    query:
      big: true
      color: [red, blue] # This parameter has multiple values
      name: "Barry"
</code></pre>
<p>This will generate the URL <code>https://myfishes.fish/fishes?big=true&amp;color=red&amp;color=blue&amp;name=Barry</code>.</p>
<h2 id="headers"><a class="header" href="#headers">Headers</a></h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Glossary/Request_header">HTTP request headers</a> are specified via the <code>headers</code> field, which is a mapping of <code>{header: value}</code>. The keys (header names) must be static, but values can be templated. Typically header values are UTF-8 text, but can be any arbitrary stream of bytes compliant with the HTTP spec.</p>
<pre><code class="language-yaml">profiles:
  default:
    data:
      host: https://myfishes.fish

recipes:
  get_fishes:
    method: GET
    url: "https://myfishes.fish/fishes"
    headers:
      X-Custom-Header: "You are https://myfishes.fish"
</code></pre>
<blockquote>
<p>Before manually specifying headers, read the sections below on <a href="user_guide/recipes.html#authentication">authentication</a> and <a href="user_guide/recipes.html#body">request bodies</a>. Slumber has first-class support for common request features that may make it unnecessary to specify headers such as <code>Content-Type</code> or <code>Authorization</code>.</p>
</blockquote>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<blockquote>
<p>See the <a href="user_guide/../api/request_collection/authentication.html">API docs</a> for more detailed info.</p>
</blockquote>
<p>Slumber supports multiple methods of request authentication, making it easier to build request with common authentication schemes. The supported types currently are:</p>
<ul>
<li>Basic (username/password)</li>
<li>Bearer (API token)</li>
</ul>
<p>If you'd like support for a new authentication scheme, please <a href="https://github.com/LucasPickering/slumber/issues/new">file an issue</a>.</p>
<pre><code class="language-yaml">requests:
  basic_auth:
    method: GET
    url: "https://myfishes.fish/fishes"
    authentication:
      type: basic
      username: user
      password: hunter2

  bearer_auth:
    method: GET
    url: "https://myfishes.fish/fishes"
    authentication:
      type: bearer
      token: my-token
</code></pre>
<h2 id="body"><a class="header" href="#body">Body</a></h2>
<blockquote>
<p>See the <a href="user_guide/../api/request_collection/recipe_body.html">API docs</a> for more detailed info.</p>
</blockquote>
<p>Slumber supports a number of different body types:</p>
<ul>
<li>Raw text/bytes</li>
<li>JSON</li>
<li>URL-encoded forms (<code>application/x-www-form-urlencoded</code>)</li>
<li>Multipart forms (<code>multipart/form-data</code>)</li>
</ul>
<p>Here's an example of each one in practice:</p>
<pre><code class="language-yaml">requests:
  text_body:
    method: POST
    url: "https://myfishes.fish/fishes/42/name"
    headers:
      Content-Type: text/plain
    body: Alfonso

  binary_body:
    method: POST
    url: "https://myfishes.fish/fishes/42/image"
    headers:
      Content-Type: image/jpg
    body: "{{ file('./fish.png') }}"

  json_body:
    method: POST
    url: "https://myfishes.fish/fishes/42"
    # Content-Type header will be set to `application/json` automatically
    body:
      type: json
      data: { "name": "Alfonso" }

  urlencoded_body:
    method: POST
    url: "https://myfishes.fish/fishes/42"
    # Content-Type header will be set to `application/x-www-form-urlencoded` automatically
    body:
      type: form_urlencoded
      data:
        name: Alfonso

  multipart_body:
    method: POST
    url: "https://myfishes.fish/fishes/42"
    # Content-Type header will be set to `multipart/form-data` automatically
    body:
      type: form_multipart
      data:
        name: Alfonso
        image: b"\x12\x34"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="templates"><a class="header" href="#templates">Templates</a></h1>
<p>Templates enable dynamic request construction. Slumber's template language is relatively simple when compared to HTML templating languages such as Handlebars or Jinja. The goal is to be simple, intuitive, and unsurprising. Every value in a request (except for the HTTP method) is a template, meaning it can be computed dynamically.</p>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<p>Slumber templates in 60 seconds or less:</p>
<ul>
<li>Double curly braces <code>{{...}}</code> denotes a dynamic value in a template</li>
<li>Literals:
<ul>
<li>Null: <code>null</code></li>
<li>Booleans: <code>true</code> and <code>false</code></li>
<li>Integers: <code>-3</code> or <code>1000</code></li>
<li>Floats: <code>-3.14</code>, <code>1000.0</code>, <code>3.14e2</code></li>
<li>String: <code>'hello'</code> or <code>"hello"</code> (single or double quotes)
<ul>
<li>Escape inner quotes with <code>\</code></li>
</ul>
</li>
<li>Bytes: <code>b'hello'</code> or <code>b"hello"</code></li>
<li>Array: <code>[1, "hello", [true, b"world"]]</code></li>
</ul>
</li>
<li>Profile fields: <code>host</code> (see <a href="user_guide/templates/../profiles.html">Profiles</a>)</li>
<li>Function calls: <code>g(f(), 1)</code>
<ul>
<li><a href="user_guide/templates/../../api/template_functions.html">See all available functions</a></li>
</ul>
</li>
<li>Pipes: <code>f() | g(1)</code>
<ul>
<li>Result of <code>f()</code> is passed as the <em>last</em> argument to <code>g</code></li>
<li><code>f() | g(1)</code> is equivalent to <code>g(1, f())</code></li>
</ul>
</li>
</ul>
<p>Put it all together and you can build collections like this:</p>
<pre><code class="language-python">{{ host }}/fish/{{ response('list_fish') | jsonpath('$[0].id') }}
</code></pre>
<p>If you still have questions, you can keep reading or <a href="user_guide/templates/./examples.html">skip to some examples</a>.</p>
<h2 id="yaml-syntax"><a class="header" href="#yaml-syntax">YAML Syntax</a></h2>
<p>Templates are defined as strings in your request collection YAML file. For example, here's a template for a request URL:</p>
<pre><code class="language-yaml">requests:
  list_fish:
    method: GET
    url: "{{ host }}/fish"
</code></pre>
<p>Most values in a request collection (e.g. URL, request body, etc.) are templates. <a href="user_guide/templates/../profiles.html#dynamic-profile-values">Even profile values are templates!</a> Map keys (e.g. recipe ID, profile ID) are <em>not</em> templates; they must be static strings.</p>
<blockquote>
<p><strong>A note on YAML string syntax</strong></p>
<p>One of the advantages (and disadvantages) of YAML is that it has a number of different string syntaxes. This enables you to customize your templates according to your specific needs around the behavior of whitespace and newlines. <strong>In most cases, you should just use <code>""</code> on all strings.</strong> See <a href="https://www.educative.io/answers/how-to-represent-strings-in-yaml">YAML's string syntaxes</a> and <a href="https://yaml-multiline.info/">yaml-multiline.info</a> for more info.</p>
</blockquote>
<p>Not all template are dynamic. Static strings are also valid templates and just render to themselves:</p>
<pre><code class="language-yaml">requests:
  list_fish:
    method: GET
    # This is a valid template
    url: "https://myfishes.fish/fish"
    # Numbers and booleans can also be templates!
    query:
      number_param: 3 # Parses as the template "3"
      bool_param: false # Parses as "false"
</code></pre>
<h2 id="escape-sequences"><a class="header" href="#escape-sequences">Escape Sequences</a></h2>
<p>In some scenarios you may want to use the <code>{{</code> sequence to represent those literal characters, rather than the start of a template key. To achieve this, you can escape the sequence with an underscore inside it, e.g. <code>{_{</code>. If you want the literal string <code>{_{</code>, then add an extra underscore: <code>{__{</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Template</th><th>Parses as</th></tr></thead><tbody>
<tr><td><code>{_{this is raw text}}</code></td><td><code>["{{this is raw text}}"]</code></td></tr>
<tr><td><code>{_{{field1}}</code></td><td><code>["{", field("field1")]</code></td></tr>
<tr><td><code>{__{{field1}}</code></td><td><code>["{__", field("field1")]</code></td></tr>
<tr><td><code>{_</code></td><td><code>["{_"]</code> (no escaping)</td></tr>
</tbody></table>
</div>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<p>Why does Slumber have its own template language? Why not use Jinja/Handlebars/Tera/Liquid/etc?</p>
<ul>
<li>Rust integration. Not all template languages have a Rust interface that enables the flexibility that Slumber needs.</li>
<li>Support for lazy expressions. Some languages require all available values in template to be precomputed, which is incompatible with Slumber's dynamic data sources.</li>
<li>Binary values. Most template languages focus on generating strings and don't support binary output values. Binary values are necessary for Slumber because not all HTTP requests are strings. For example, loading an image from a file and uploading it to a server involves non-textual template values.</li>
<li>Simplicity. Most template languages are written for the purpose of building websites, which means generating HTML. This involves complex features such as conditionals and for loops. Slumber's needs are much more narrow. By simplifying the template language, it reduces the level of complexity available to users. This is a tradeoff: an easier learning curve, at the cost of less power.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="values"><a class="header" href="#values">Values</a></h1>
<p>Templates contain expressions, and expressions evaluate to values. Template values are basically JSON values, with the addition of one more type: <code>bytes</code>. Here's the full list:</p>
<ul>
<li><code>null</code></li>
<li><code>boolean</code>: <code>true</code> or <code>false</code></li>
<li><code>float</code>
<ul>
<li>Uses <a href="https://doc.rust-lang.org/std/primitive.f64.html">f64</a> internally. See docs for information on min/max values.</li>
</ul>
</li>
<li><code>integer</code> (signed integer)
<ul>
<li>Uses <a href="https://doc.rust-lang.org/std/primitive.i64.html">i64</a> internally. See docs for information on min/max values.</li>
</ul>
</li>
<li><code>string</code>: <code>"hello!"</code> or <code>'hello!'</code>
<ul>
<li>Single-quote format is more common because your templates will often be wrapped in <code>"</code> to denote a YAML string</li>
</ul>
</li>
<li><code>bytes</code>: <code>b"hello!"</code> or <code>b'hello!'</code></li>
<li><code>array</code>: <code>[1, false, 'hello!']</code></li>
<li><code>object</code>: <code>{ 'a': 1, 'b': 2 }</code>
<ul>
<li>Object keys must be strings. If a non-string value is given, it will be stringified</li>
</ul>
</li>
</ul>
<h2 id="bytes-vs-string"><a class="header" href="#bytes-vs-string"><code>bytes</code> vs <code>string</code></a></h2>
<p>A <code>string</code> is technically a subset of <code>bytes</code>: any sequence of valid UTF-8 bytes can be a <code>string</code>. Many functions return a <code>bytes</code> value because Slumber doesn't know if the value is valid UTF-8 or not. You may wonder: what do I do with this? How do I turn it into a string? You don't have to! There are three scenarios in which <code>bytes</code> can be used:</p>
<ul>
<li>You have a <code>bytes</code> but need a <code>string</code>. The bytes are valid UTF-8. Slumber will automatically convert it to a <code>string</code> when necessary.</li>
<li>You have a <code>bytes</code> but need a <code>string</code>. The bytes are <strong>not</strong> valid UTF-8. Slumber will attempt to convert it to a <code>string</code> and fail, returning an error during request render.</li>
<li>You have a <code>bytes</code> and need a <code>bytes</code> (e.g. for a request body, which doesn't need to be valid UTF-8). Easy!</li>
</ul>
<p>So the short answer is: if you see a function return <code>bytes</code>, you can generally pretend it says <code>string</code>. The types are distinct to acknowledge the fact that the <code>bytes</code> <em>may</em> not be valid UTF-8, and therefore may trigger errors while rendering a request.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Template functions enable you to build dynamic templates in a way that's intuitive and composable. Slumber templates behave as a simple functional language: functions take arguments and evaluate to values. All functions are provided by Slumber; <strong>there is no way to define your own functions.</strong></p>
<p><strong>For the list of available functions, see <a href="user_guide/templates/../../api/template_functions.html">Template Functions</a>.</strong></p>
<h2 id="arguments"><a class="header" href="#arguments">Arguments</a></h2>
<p>Slumber functions take two types of arguments:</p>
<ul>
<li>Positional arguments are specified in a specific and are always required</li>
<li>Keyword arguments as passed in the form <code>key=value</code>, can be specified in any order (provided all positional arguments are passed first), and are always optional</li>
</ul>
<p>In the function signatures listed below, keyword arguments are specified with a <code>?</code> while positional arguments are not.</p>
<p>For example, this function takes 2 required positional arguments and 2 optional keyword arguments:</p>
<pre><code class="language-typescript">func(a: string, b: boolean, c?: string, d?: bytes): string
</code></pre>
<p>Given this function signature, the following are all valid calls:</p>
<pre><code class="language-python">func("hello", true);
func("hello", true, "world");
func("hello", true, c="world");
func("hello", true, d=b"bytes");
func("hello", true, c="world", d=b"bytes");
func("hello", true, d=b"bytes", c="world"); # Keyword args can be reordered
</code></pre>
<p>The follow calls are <strong>not valid</strong>:</p>
<pre><code class="language-python"># WARNING: Invalid code!!
func("hello") # Required arguments omitted
func(c="world", "hello", true) # Keyword argument before positional
func("hello", true, c="world", c="world") # Keyword argument given twice
func("hello", true, "world") # Optional arguments must be given by name
</code></pre>
<h3 id="defaults"><a class="header" href="#defaults">Defaults</a></h3>
<p>If a keyword argument is omitted, it will be replaced by a default value. In most cases, the default will be based on the type of the argument:</p>
<ul>
<li><code>boolean</code>: <code>false</code></li>
<li><code>float</code>: <code>0.0</code></li>
<li><code>integer</code>: <code>0</code></li>
<li><code>string</code>: <code>""</code></li>
<li><code>bytes</code>: <code>b""</code></li>
<li><code>array</code>: <code>[]</code></li>
<li><code>value</code>: <code>null</code></li>
</ul>
<p>If the default varies from this list, it will be specified in the <code>Parameters</code> section of the function's docs.</p>
<h2 id="pipe-operator"><a class="header" href="#pipe-operator">Pipe Operator</a></h2>
<p>It's common to take the output of one function and pass it to another. This is especially useful for filter-esque functions like <a href="user_guide/templates/../../api/template_functions.html#jsonpath"><code>jsonpath</code></a> and <a href="user_guide/templates/../../api/template_functions.html#trim"><code>trim</code></a> that modify incoming input. Here's an example using <a href="user_guide/templates/../../api/template_functions.html#command"><code>command</code></a> and <a href="user_guide/templates/../../api/template_functions.html#trim"><code>trim</code></a></p>
<pre><code class="language-python"># Command output often includes a trailing newline that we want to trim away
trim(command(["echo", "hello"]))
</code></pre>
<p>This works, but it's a bit backward: we run the <code>command</code>, <em>then</em> <code>trim</code> it. To make these types of composed operations easier to read and write, Slumber supports the pipe operator <code>|</code>. The left-hand side of the operator can be any expression, but is typically a function call. The right-hand side <strong>must be a function call</strong>. The left-hand side is evaluated, then the result is passed as the <strong>last</strong> argument to the right-hand side. We can rewrite the same expression from above with the pipe:</p>
<pre><code class="language-python"># Equivalent to the above expression
command(["echo", "hello"]) | trim()
</code></pre>
<p>This is equivalent, but easier to read because the lexical ordering of calls matches the evaluation order.</p>
<blockquote>
<p>Unlike other template languages such as Jinja and Tera, the right-hand side of a pipe <strong>must include parentheses</strong>, even if they argument list is empty. Additionally, other languages have a distinction between "functions" and "filters", and only filters can be used on the right-hand side of a pipe operation. This distinction does <strong>not</strong> exist in Slumber; any function can be used on the right-hand side of a pipe, as long as it takes at least one positional argument.</p>
</blockquote>
<p>Remember: the piped value is passed as the <strong>last</strong> positional argument to the right-hand side. That means it will be inserted after other positional arguments but before any keyword arguments. Here's another example, using <a href="user_guide/templates/../../api/template_functions.html#response"><code>response</code></a> and <a href="user_guide/templates/../../api/template_functions.html#jsonpath"><code>jsonpath</code></a>.</p>
<pre><code class="language-python">response('login') | jsonpath("$.token", mode="single")
# is equivalent to
jsonpath("$.token", response('login'), mode="single")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<h2 id="profiles"><a class="header" href="#profiles">Profiles</a></h2>
<p>Let's start with a simple example. Let's say you're working on a fish-themed website, and you want to make requests both to your local stack and the deployed site. Templates, combined with <a href="user_guide/templates/../profiles.html">profiles</a>, allow you to easily switch between hosts:</p>
<blockquote>
<p>For the purposes of these examples, I've made up some theoretical endpoints and responses, following standard REST practice. This isn't a real API but it should get the point across.</p>
<p>Additionally, these examples will use the CLI because it's easy to demonstrate in text. All these concepts apply equally to the TUI.</p>
</blockquote>
<pre><code class="language-yaml">profiles:
  local:
    data:
      host: http://localhost:5000
  production:
    data:
      host: https://myfishes.fish

requests:
  list_fish:
    method: GET
    url: "{{ host }}/fishes"
    query:
      big: true
</code></pre>
<p>Now you can easily select which host to hit. In the TUI, this is done via the Profile list. In the CLI, use the <code>--profile</code> option:</p>
<pre><code class="language-sh">&gt; slumber request --profile local list_fish
# http://localhost:5000/fishes
# Only one fish :(
[{"id": 1, "kind": "tuna", "name": "Bart"}]
&gt; slumber request --profile production list_fish
# https://myfishes.fish/fishes
# More fish!
[
  {"id": 1, "kind": "marlin", "name": "Kim"},
  {"id": 2, "kind": "salmon", "name": "Francis"}
]
</code></pre>
<h2 id="chaining-requests"><a class="header" href="#chaining-requests">Chaining requests</a></h2>
<p>One of Slumber's most powerful tools is the ability to chain requests together: send request 1, get some data from its response, then include that in request 2. Here's a series of examples showing how you can accomplish this.</p>
<h3 id="load-data-from-response"><a class="header" href="#load-data-from-response">Load data from response</a></h3>
<p>If you want to send a request that includes data derived from a previous response, you can use the <a href="user_guide/templates/../../api/template_functions.html#response"><code>response</code></a> function.</p>
<pre><code class="language-yaml">requests:
  list_fish:
    method: GET
    url: "{{ host }}/fishes"
  post_fish_list:
    method: POST
    url: "{{ host }}/fishes"
    body: "{{ response('list_fish') }}"
</code></pre>
<p><code>response</code> on its own is not very useful. Typically you want to extract some data from the response to include in your request. See the next example for this.</p>
<h3 id="data-extraction-via-jsonpath"><a class="header" href="#data-extraction-via-jsonpath">Data extraction via JSONPath</a></h3>
<p><a href="https://jsonpath.com/">JSONPath</a> is a simple query language for extracting data from JSON documents. Slumber has a <a href="user_guide/templates/../../api/template_functions.html#jsonpath"><code>jsonpath</code></a> function for this purpose.</p>
<p>In this example, we extract the first fish from <code>list_fish</code> to get additional details about it:</p>
<pre><code class="language-yaml">requests:
  list_fish:
    method: GET
    url: "{{ host }}/fishes"
  get_fish:
    method: GET
    url: "{{ host }}/fishes/{{ response('fish_list') | jsonpath('$[0].id') }}"
</code></pre>
<p>The JSONPath query here is <code>$[0].id</code>, meaning it selects the <code>id</code> property from the first fish in the response.</p>
<h3 id="dynamic-select-lists-with-select"><a class="header" href="#dynamic-select-lists-with-select">Dynamic select lists with <code>select</code></a></h3>
<p>Fetching the first fish is neat and all, but what if you want to select which fish to fetch? Enter the <a href="user_guide/templates/../../api/template_functions.html#select"><code>select</code></a> function! You can combine <code>select</code> with <code>jsonpath</code> to build dynamic selection lists:</p>
<pre><code class="language-yaml">requests:
  list_fish:
    method: GET
    url: "{{ host }}/fishes"
  get_fish:
    method: GET
    url: "{{ host }}/fishes/{{ response('fish_list') | jsonpath('$[*].id', mode='array') | select() }}"
</code></pre>
<p>Notice that in this example, the JSONPath has changed from <code>$[0].id</code> to <code>$[*].id</code>, so it selects the <code>id</code> property from <em>every</em> fish in the response, creating a list of IDs. Piping that to <code>select</code> will pop up a dialog with all the available fish IDs.</p>
<p>Also note the <code>mode='array'</code> argument to <code>jsonpath</code>. This tells <code>jsonpath</code> to always return an array of values, even if there is only one available. This is necessary because <code>select</code> must take in an array. See the <code>mode</code> argument of <a href="user_guide/templates/../../api/template_functions.html#jsonpath"><code>jsonpath</code></a> for more info.</p>
<h3 id="triggering-upstream-requests"><a class="header" href="#triggering-upstream-requests">Triggering upstream requests</a></h3>
<p>These examples are all neat and fancy, but they rely on you manually running <code>list_fish</code>. If you want your list of available fish you update, you'll have to kick it off manually. But we can do better! <code>response</code> takes an additional argument called <code>trigger</code>, enabling Slumber to automatically trigger the upstream request (in this case, <code>list_fish</code>) under certain conditions. The options for <code>trigger</code> are:</p>
<ul>
<li><code>"never"</code>: The default behavior</li>
<li><code>"no_history"</code>: Trigger only if <code>list_fish</code> has never been run before</li>
<li><code>"always"</code>: Trigger <code>list_fish</code> every time we send <code>get_fish</code></li>
<li>Duration: Trigger <code>list_fish</code> if the last response is older than a specific time span</li>
</ul>
<p>The first 3 options are pretty straight forward, so let's dig in the Duration option. Let's say we don't think fish will be added or removed <em>that</em> often, so only trigger <code>list_fish</code> if it's more than a day old.</p>
<pre><code class="language-yaml">requests:
  list_fish:
    method: GET
    url: "{{ host }}/fishes"
  get_fish:
    method: GET
    url: "{{ host }}/fishes/{{ response('fish_list', trigger='1d') | jsonpath('$[*].id', mode='array') | select() }}"
</code></pre>
<p>That's it! Just add <code>trigger='1d'</code> and Slumber handles the rest. See the docs for <a href="user_guide/templates/../../api/template_functions.html#response"><code>response</code></a> for more info on the trigger duration format.</p>
<h2 id="deduplicating-template-expressions"><a class="header" href="#deduplicating-template-expressions">Deduplicating template expressions</a></h2>
<p>As the previous examples have shown, template expressions can get pretty complicated. Slumber's template language doesn't support variables or assignment, so how can we break a template up into simpler pieces? This is especially useful when you want to use the same complicated template in multiple places. We can achieve this through <a href="user_guide/templates/../profiles.html#dynamic-profile-values">dynamic profile values</a>:</p>
<pre><code class="language-yaml">profiles:
  local:
    host: http://localhost:5000
    fish_id: "{{ response('fish_list', trigger='1d') | jsonpath('$[*].id', mode='array') | select() }}"

requests:
  list_fish:
    method: GET
    url: "{{ host }}/fishes"
  get_fish:
    method: GET
    url: "{{ host }}/fishes/{{ fish_id }}"
  delete_fish:
    method: DELETE
    url: "{{ host }}/fishes/{{ fish_id }}"
</code></pre>
<p>Now we can easily use that template in multiple recipes. <strong>But</strong>, what if we have multiple profiles? We wouldn't want to copy-paste that template across every profile. Using <a href="user_guide/templates/../composition.html">composition</a>, we can define the template in one place and share it in every profile:</p>
<pre><code class="language-yaml">.base_profile_data: &amp;base_profile_data
  fish_id: "{{ response('fish_list', trigger='1d') | jsonpath('$[*].id', mode='array') | select() }}"

profiles:
  local:
    &lt;&lt;: *base_profile_data
    host: http://localhost:5000
  production:
    &lt;&lt;: *base_profile_data
    host: https://myfishes.fish

requests:
  list_fish:
    method: GET
    url: "{{ host }}/fishes"
  get_fish:
    method: GET
    url: "{{ host }}/fishes/{{ fish_id }}"
  delete_fish:
    method: DELETE
    url: "{{ host }}/fishes/{{ fish_id }}"
</code></pre>
<h2 id="non-string-json-templates"><a class="header" href="#non-string-json-templates">Non-string JSON templates</a></h2>
<p><a href="user_guide/templates/../recipes.html#body">JSON bodies</a> support dynamic non-string values. By using a template with a single dynamic chunk (i.e. a single <code>{{ ... }}</code>), you can create non-string values. Let's say we have a JSON file <code>./friends.json</code> with this content:</p>
<pre><code class="language-json">["Barry", "Dora"]
</code></pre>
<p>We can use this file in a request body:</p>
<pre><code class="language-yaml">requests:
  json_body:
    method: POST
    url: "https://myfishes.fish/fishes/{{ fish_id }}"
    body:
      type: json
      data:
        {
          "name": "Alfonso",
          "friends": "{{ file('./friends.json') | json_parse() }}",
        }
</code></pre>
<p>The request body will render as:</p>
<pre><code class="language-json">{
  "name": "Alfonso",
  "friends": ["Barry", "Dora"]
}
</code></pre>
<p>A few things to notice here:</p>
<ul>
<li>We had to explicitly parse the contents of the file with <code>json_parse()</code>. By default the content loaded is just artbirary bytes; Slumber doesn't know it's supposed to be JSON.</li>
<li>The parsed JSON is included directly into the JSON body, <em>without</em> the surrounding quotes from the template. In other words, the value was <strong>unpacked</strong>.</li>
</ul>
<p>In some cases this behavior may not be desired, e.g. when combined with <code>jsonpath()</code>. You can pipe to <code>string()</code> to <strong>disable this behavior</strong>:</p>
<pre><code class="language-yaml">requests:
  json_body:
    method: POST
    url: "https://myfishes.fish/fishes/{{ fish_id }}"
    body:
      type: json
      data:
        {
          "name": "Alfonso",
          "friends": "{{ file('./friends.json') | jsonpath('$[*]') | string() }}",
        }
</code></pre>
<p>This will render to:</p>
<pre><code class="language-json">{
  "name": "Alfonso",
  "friends": "[\"Barry\", \"Dora\"]"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="profiles-1"><a class="header" href="#profiles-1">Profiles</a></h1>
<p>A profile is a set of values accessible to templates that you can easily switch between. In the TUI, this is via the Profiles modal (hotkey <code>p</code> by default). In the CLI, use the <code>--profile</code> (or <code>-p</code>) flag.</p>
<p>The canonical use case for profiles is to switch between different API hosts. Here's what that looks like:</p>
<pre><code class="language-yaml">profiles:
  local:
    data:
      host: http://localhost:5000
  production:
    data:
      host: https://myfishes.fish

requests:
  list_fish:
    method: GET
    url: "{{ host }}/fishes"
</code></pre>
<p>But profiles aren't restricted to setting the API host. The <code>data</code> field can hold whatever fields you want. Here's an example of setting your API user via profiles:</p>
<pre><code class="language-yaml">profiles:
  user1:
    data:
      username: user1
  user2:
    data:
      username: user2

requests:
  list_fish:
    method: GET
    url: "https://myfishes.fish/fishes"
    authentication:
      type: basic
      username: "{{ username }}"
      password: "{{ file('./password.txt') }}"
</code></pre>
<h2 id="dynamic-profile-values"><a class="header" href="#dynamic-profile-values">Dynamic profile values</a></h2>
<p>Fun fact: profile values <em>are</em> templates! This means you can put dynamic values in your profiles and they'll be rendered automatically with no extra effort. For example, if you want a profile for each user that you may log in as, plus an additional profile that lets you prompt for a username:</p>
<pre><code class="language-yaml">profiles:
  user1:
    data:
      username: user1
  user2:
    data:
      username: user2
  user_prompt:
    data:
      username: "{{ prompt(message='Username') }}"

requests:
  list_fish:
    method: GET
    url: "https://myfishes.fish/fishes"
    authentication:
      type: basic
      username: "{{ username }}"
      password: "{{ file('./password.txt') }}"
</code></pre>
<p>When you send the <code>list_fish</code> command with the <code>user_prompt</code> profile selected, it will prompt you to enter a username, then user that value for <code>{{ username }}</code>.</p>
<p>This feature can also be used to <a href="user_guide/./templates/examples.html#deduplicating-template-expressions">deduplicate common template expressions</a>.</p>
<h2 id="template-caching"><a class="header" href="#template-caching">Template caching</a></h2>
<p>In the example above, we saw how a profile field can contain a dynamic template. These dynamic profile fields are automatically cached within the scope of a single request. This means if you use the same field multiple times in a request, <strong>the template will only be rendered once</strong>. Here's an extension of the above example:</p>
<pre><code class="language-yaml">profiles:
  user1:
    data:
      username: user1
  user2:
    data:
      username: user2
  user_prompt:
    data:
      username: "{{ prompt(message='Username') }}"

requests:
  list_fish:
    method: GET
    url: "https://myfishes.fish/fishes"
    authentication:
      type: basic
      username: "{{ username }}"
      password: "{{ file('./password.txt') }}"
    query:
      username: "{{ username }}"
</code></pre>
<p>In this example, two different fields in the request (<code>authentication.username</code> and <code>query.username</code>) both reference the <code>username</code> profile field. But the corresponding template <code>{{ prompt(message='Username') }}</code> <strong>is only rendered once</strong>. That means you'll only be prompted once for a username, and entered value will be used for both instances of <code>{{ username }}</code>.</p>
<p>This caching applies only when a single profile field is referenced multiple times within a single request. If you send the same request a second time, you will be prompted again for a username.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collection-reuse-with-ref"><a class="header" href="#collection-reuse-with-ref">Collection Reuse with <code>$ref</code></a></h1>
<p>Slumber supports a <code>$ref</code> anywhere in any YAML file that allows referencing any other part of a YAML document (including other files). It uses the <a href="https://datatracker.ietf.org/doc/html/draft-pbryan-zyp-json-ref-03">JSON Reference</a> and <a href="https://datatracker.ietf.org/doc/html/rfc6901">JSON Pointer</a> notation used by <a href="https://swagger.io/docs/specification/v3_0/using-ref/">OpenAPI</a>.</p>
<p>The format of the <code>$ref</code> is a <a href="https://datatracker.ietf.org/doc/html/rfc3986">URI</a> with an optional base/path. The base can be:</p>
<ul>
<li>Empty, indicating a reference within the same file</li>
<li>A file path, indicating a reference to another file
<ul>
<li>Path is always relative to <strong>the importing file</strong></li>
</ul>
</li>
</ul>
<pre><code class="language-yaml">requests:
  list_fish:
    method: GET
    url: "{{ host }}/fishes"

  get_fish:
    method:
      $ref: "#/requests/list_fish/method"
    url: "{{ host }}/fishes/{{ fish_id }}"
</code></pre>
<p>The reference <em>source</em> is everything before the <code>#</code>; the pointer is everything after.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>Let's start with an example of something that sucks. Let's say you're making requests to a fish-themed JSON API, and it requires authentication. Gotta protect your fish! Your request collection might look like so:</p>
<pre><code class="language-yaml">profiles:
  local:
    data:
      host: http://localhost:3000
      fish_id: 6
  production:
    data:
      host: https://myfishes.fish
      fish_id: 6

requests:
  list_fish:
    method: GET
    url: "{{ host }}/fishes"
    query:
      big: true
    headers:
      Accept: application/json
    authentication:
      type: bearer
      token: "{{ file('./api_token.txt') | trim() }}"

  get_fish:
    method: GET
    url: "{{ host }}/fishes/{{ fish_id }}"
    headers:
      Accept: application/json
    authentication:
      type: bearer
      token: "{{ file('./api_token.txt') | trim() }}"
</code></pre>
<h2 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h2>
<p>You've heard of <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>, so you know this is bad. Every profile has to include the fish ID, and every new request recipe has to copy-paste the authentication and headers.</p>
<p>You can easily reuse components of your collection using <code>$ref</code>:</p>
<pre><code class="language-yaml"># The name here is arbitrary, pick any name you like. Make sure it starts with
# . to avoid errors about an unknown field
.base_profile_data:
  fish_id: 6
.base_request:
  headers:
    Accept: application/json
  authentication:
    type: bearer
    token: "{{ file('./api_token.txt') | trim() }}"

profiles:
  local:
    data:
      $ref: "#/.base_profile_data"
      host: http://localhost:3000
  production:
    data:
      $ref: "#/.base_profile_data"
      host: https://myfishes.fish

requests:
  list_fish:
    $ref: "#/.base_request"
    method: GET
    url: "{{ host }}/fishes"
    query:
      big: true

  get_fish:
    $ref: "#/.base_request"
    method: GET
    url: "{{ host }}/fishes/{{ fish_id }}"
</code></pre>
<p>Great! That's so much cleaner. Now each recipe can inherit whatever base properties you want just by including <code>$ref: "#/.base_request"</code>. This is still a bit repetitive, but it has the advantage of being explicit. You may have some requests that <em>don't</em> want to include those values.</p>
<h2 id="recursive-composition"><a class="header" href="#recursive-composition">Recursive Composition</a></h2>
<p>But wait! What if you have a new request that needs an additional header? Unfortunately, <code>$ref</code> does not support recursive merging. If you need to extend the <code>headers</code> map from the base request, you'll need to pull the parent <code>headers</code> in manually:</p>
<pre><code class="language-yaml">.base_request:
  headers:
    Accept: application/json
  authentication:
    type: bearer
    token: "{{ file('./api_token.txt') | trim() }}"

requests:
  create_fish:
    $ref: "#/.base_request"
    method: GET
    url: "{{ host }}/fishes/{{ fish_id }}"
    headers:
      $ref: "#/.base_request/headers"
      Host: myfishes.fish
    body:
      type: json
      data: { "kind": "barracuda", "name": "Barry" }
</code></pre>
<h2 id="cross-file-composition"><a class="header" href="#cross-file-composition">Cross-File Composition</a></h2>
<p>Reusing components within a single file is great and all, but <code>$ref</code> also supports importing components from other files:</p>
<p><strong>base.yml</strong></p>
<pre><code class="language-yaml">requests:
  login:
    method: POST
    url: "{{ host }}/login"
    body:
      type: json
      data:
        {
          "username": "{{ prompt(message='Username') }}",
          "password": "{{ prompt(message='Password', sensitive=true) }}",
        }
</code></pre>
<p><strong>slumber.yml</strong></p>
<pre><code class="language-yaml">requests:
  login:
    $ref: "./base.yml#/requests/login"
</code></pre>
<blockquote>
<p>Referenced files do <em>not</em> need to be valid Slumber collections; any valid YAML file can be referenced</p>
</blockquote>
<h2 id="replacement-vs-extension"><a class="header" href="#replacement-vs-extension">Replacement vs Extension</a></h2>
<p>Depending on how <code>$ref</code> is used, the referenced value will either replace or extend the reference.</p>
<ul>
<li>If <code>$ref</code> is the only field in its mapping, the entire mapping will be replaced</li>
<li>If there are other fields in <code>$ref</code>, just the <code>$ref</code> <em>field</em> will be replaced by the fields in the referenced mapping
<ul>
<li>In this case, the referenced value <strong>must be a mapping</strong>; any other value type will trigger an error</li>
</ul>
</li>
</ul>
<pre><code class="language-yaml">refs:
  string: "hello!"
  mapping:
    a: 1
    b: 2

# `string`'s mapping value is replaced by the referenced string
# string: "hello!"
string:
  $ref: "#/refs/string"

# `mapping`'s mapping value is replaced by another mapping. This is functionally
# equivalent to extending `mapping` with `refs/mapping`.
#
# mapping:
#   a: 1
#   b: 2
mapping:
  $ref: "#/refs/mapping"

# The values of `refs/mapping` are replaced exactly where $ref is. `mapping/a`
# is overridden by `refs/mapping/a`, but `mapping/b` overrides `refs/mapping/b`
#
# mapping_extend:
#   a: 1
#   b: 3
mapping_extend:
  a: 0
  $ref: "#/refs/mapping"
  b: 3

# Error! Can't extend a mapping with a string
mapping_error:
  $ref: "#/refs/string"
  b: 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-streaming--file-upload"><a class="header" href="#data-streaming--file-upload">Data Streaming &amp; File Upload</a></h1>
<p>If you want to generate HTTP requests with very large bodies, you may want to use streams to upload</p>
<p>In addition to reducing memory usage and saving the TUI from having to load and display a giant body, streaming also enables some additional features for <a href="user_guide/../api/request_collection/recipe_body.html#multipart-form">multipart form bodies</a>.</p>
<h2 id="what-is-streaming"><a class="header" href="#what-is-streaming">What is Streaming?</a></h2>
<p>Streaming is when the HTTP client sends bytes directly from a source such as a file to the HTTP server without loading the entire body into memory. It's useful when the body is very large because it saves time and memory.</p>
<h2 id="streaming-in-slumber"><a class="header" href="#streaming-in-slumber">Streaming in Slumber</a></h2>
<p>Slumber supports streaming in these contexts:</p>
<ul>
<li><code>stream</code> request body</li>
<li><code>form_multipart</code> request body fields</li>
</ul>
<p>and from these functions:</p>
<ul>
<li><a href="user_guide/../api/template_functions.html#command">command</a></li>
<li><a href="user_guide/../api/template_functions.html#file">file</a></li>
</ul>
<pre><code class="language-yaml"># These bodies **WILL** be streamed
file:
  method: POST
  url: "{{ host }}/upload"
  body:
    type: stream
    data: "{{ file('image.png') }}"

command:
  method: POST
  url: "{{ host }}/upload"
  body:
    type: stream
    data: "here's some bytes: {{ command(['head', '-c', '1000', '/dev/random']) }}"

multipart:
  method: POST
  url: "{{ host }}/upload"
  body:
    type: form_multipart
    data:
      image: "{{ file('./image.png') }}"
</code></pre>
<pre><code class="language-yaml"># These bodies will **NOT** be streamed
file:
  method: POST
  url: "{{ host }}/upload"
  # The template contains multiple chunks, so it can't be streamed
  body: "{{ file('image.png') }}"
</code></pre>
<h3 id="multipart-file-streaming"><a class="header" href="#multipart-file-streaming">Multipart File Streaming</a></h3>
<p>In addition to support for general streaming of bytes, <code>form_multipart</code> fields also have special support for file uploads. If the value of a field is a <strong>template with a single chunk</strong>, and the final call of the chunk is to <code>file()</code>, then the fille will be uploaded directly. This has two effects on that part of the form:</p>
<ul>
<li>The <code>Content-Type</code> header will be set based on the file extension</li>
<li>The <code>Content-Disposition</code> header will have the <code>filename</code> field set</li>
</ul>
<p>Here's an example:</p>
<pre><code class="language-yaml">multipart_file:
  method: POST
  url: "{{ host }}/upload"
  body:
    type: form_multipart
    data:
      image: "{{ file('./data/data.json') }}"
</code></pre>
<p>This will generate a request body like:</p>
<pre><code>--BOUNDARY
Content-Disposition: form-data; name="file"; filename="data.json"
Content-Type: application/json

{ "a": 1, "b": 2 }
--BOUNDARY--
</code></pre>
<p>But if you generate the same body with an equivalent <code>command()</code> call, the body <strong>will still be streamed</strong>, however the headers will not be set based on the file path.</p>
<pre><code class="language-yaml">multipart_command:
  method: POST
  url: "{{ host }}/upload"
  body:
    type: form_multipart
    data:
      image: "{{ command(['cat', './data/data.json']) }}"
</code></pre>
<p>This will generate a request body like:</p>
<pre><code>--BOUNDARY
Content-Disposition: form-data; name="file"

{ "a": 1, "b": 2 }
--BOUNDARY--
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="importing-external-collections"><a class="header" href="#importing-external-collections">Importing External Collections</a></h1>
<p>You can import external collection formats such as OpenAPI into Slumber collections. See the <a href="user_guide/./cli/subcommands.html#slumber-import"><code>slumber import</code></a> subcommand for more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminal-user-interface"><a class="header" href="#terminal-user-interface">Terminal User Interface</a></h1>
<p>The Terminal User Interface (TUI) is the primary use case for Slumber. It provides a long-lived, interactive interface for sending HTTP requests, akin to Insomnia or Postman. The difference of course is Slumber runs entirely in the terminal.</p>
<p>To start the TUI, simply run:</p>
<pre><code class="language-sh">slumber
</code></pre>
<p>This will detect your request collection file <a href="user_guide/tui/../../api/request_collection/index.html#format--loading">according to the protocol</a>. If you want to load a different file, you can use the <code>--file</code> parameter:</p>
<pre><code class="language-sh">slumber --file my-slumber.yml
</code></pre>
<h2 id="auto-reload"><a class="header" href="#auto-reload">Auto-Reload</a></h2>
<p>Once you start your Slumber, that session is tied to a single collection file. Whenever that file is modified, Slumber will automatically reload it and changes will immediately be reflected in the TUI. If auto-reload isn't working for some reason, you can manually reload the file with the <code>r</code> key.</p>
<h2 id="multiple-sessions"><a class="header" href="#multiple-sessions">Multiple Sessions</a></h2>
<p>Slumber supports running multiple sessions at once, even on the same collection. Request history is stored in a thread-safe <a href="https://www.sqlite.org/index.html">SQLite</a>, so multiple sessions can safely interact simultaneously.</p>
<p>If you frequently run multiple sessions together and want to quickly switch between them, consider a configurable terminal manager like <a href="https://github.com/tmux/tmux/wiki">tmux</a> or <a href="https://zellij.dev/">Zellij</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="in-app-editing--file-viewing"><a class="header" href="#in-app-editing--file-viewing">In-App Editing &amp; File Viewing</a></h1>
<h2 id="editing"><a class="header" href="#editing">Editing</a></h2>
<p><img src="user_guide/tui/../../images/editor.gif" alt="Open collection file in vim" /></p>
<p>Slumber supports editing your collection file without leaving the app. To do so, open the actions menu (<code>x</code> by default), then select <code>Edit Recipe</code>. Slumber will open an external editor to modify the selected recipe. To determine which editor to use, Slumber checks these places in the following order:</p>
<ul>
<li><code>editor</code> field of the <a href="user_guide/tui/../../api/configuration/index.html">configuration file</a></li>
<li><code>VISUAL</code> environment variable</li>
<li><code>EDITOR</code> environment variable</li>
<li>Default to <code>vim</code></li>
</ul>
<p>The <code>VISUAL</code> and <code>EDITOR</code> environment variables are a common standard to define a user's preferred text editor. For example, it's what <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration">git uses by default</a> to determine how to edit commit messages. If you want to use the same editor for all programs, you should set these. If you want to use a command specific to Slumber, set the <code>editor</code> config field.</p>
<p>Slumber supports passing additional arguments to the editor. For example, if you want to open <code>VSCode</code> and have wait for the file to be saved, you can configure your editor like so:</p>
<pre><code class="language-yaml">editor: code --wait
</code></pre>
<p>The command will be parsed like a shell command (although a shell is never actually invoked). For exact details on parsing behavior, see <a href="https://docs.rs/shell-words/1.1.0/shell_words/fn.split.html">shell-words</a>.</p>
<p>In order to open the editor to a particular line+column, Slumber uses the <code>editor-command</code> crate. Most editors support the format <code>file:line:column</code>. A few popular editors that don't support that format (<code>vim</code>, <code>emacs</code>, and <code>nano</code>) have custom behavior instead. See the <a href="https://docs.rs/editor-command/latest/editor_command/struct.Editor.html#method.open_at"><code>open_at</code></a> method for more details.</p>
<h2 id="paging"><a class="header" href="#paging">Paging</a></h2>
<p>You can open request and response bodies in a separate file browser if you want additional features beyond what Slumber provides. To configure the command to use, set the <code>PAGER</code> environment variable or the <code>pager</code> configuration field:</p>
<pre><code class="language-yaml">pager: bat
</code></pre>
<p>Slumber will check these places in the following order for a command:</p>
<ul>
<li><code>pager</code> field of the <a href="user_guide/tui/../../api/configuration/index.html">configuration file</a></li>
<li><code>PAGER</code> environment variable</li>
<li>Default to <code>less</code> (Unix) or <code>more</code> (Windows)</li>
</ul>
<blockquote>
<p>The pager command uses the same format as the <code>editor</code> field. The command is parsed with <a href="https://docs.rs/shell-words/1.1.0/shell_words/fn.split.html">shell-words</a>, then a temporary file path is passed as the final argument.</p>
</blockquote>
<p>To open a body in the pager, use the actions menu keybinding (<code>x</code> by default, see <a href="user_guide/tui/../../api/configuration/input_bindings.html">input bindings</a>), and select <code>View Body</code>.</p>
<p>Some popular pagers:</p>
<ul>
<li><a href="https://github.com/sharkdp/bat">bat</a></li>
<li><a href="https://fx.wtf/">fx</a></li>
<li><a href="https://github.com/PaulJuliusMartinez/jless">jless</a></li>
</ul>
<h3 id="setting-a-content-specific-pager"><a class="header" href="#setting-a-content-specific-pager">Setting a content-specific pager</a></h3>
<p>If you want to use a different pager for certain content types, such as using <code>jless</code> for JSON, you can pass a map of MIME type patterns to commands. For example:</p>
<pre><code class="language-yaml">pager:
  json: jless
  default: less
</code></pre>
<p>For more details on matching, see <a href="user_guide/tui/../../api/configuration/mime.html">MIME Maps</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-filtering--querying"><a class="header" href="#data-filtering--querying">Data Filtering &amp; Querying</a></h1>
<p>When browsing an HTTP response in Slumber, you may want to filter, query, or otherwise transform the response to make it easier to view. Slumber supports this via embedded shell commands. The query box at the bottom of the response pane allows you to execute any shell command, which will be passed the response body via stdin and its output will be shown in the response pane. You can use <code>grep</code>, <code>jq</code>, <code>sed</code>, or any other text processing tool.</p>
<p><img src="user_guide/tui/../../images/query_jq.gif" alt="Querying response via jq" /></p>
<p><em>Example of querying with jq</em></p>
<p><img src="user_guide/tui/../../images/query_pipe.gif" alt="Querying response with pipes" /></p>
<p><em>Example of using pipes in a query command</em></p>
<h2 id="exporting-data"><a class="header" href="#exporting-data">Exporting data</a></h2>
<p>Keep in mind that your queries are being executed as shell commands on your system. You should avoid running any commands that interact with the file system, such as using <code>&gt;</code> or <code>&lt;</code> to pipe to/from files. However, if you want to export response data from Slumber, you can do so with the export command palette. To open the export palette, select the Response pane and press the <code>export</code> key binding (<code>:</code> by default). Then enter any shell command, which will receive the response body as stdin.</p>
<blockquote>
<p><strong>Note:</strong> For text bodies, whatever text is visible in the response pane is what will be passed to stdin. So if you have a query applied, the queried body will be exported. For binary bodies, the original bytes will be exported.</p>
</blockquote>
<p>Some useful commands for exporting data:</p>
<ul>
<li><code>tee &gt; response.json</code> - Save the response to <code>response.json</code>
<ul>
<li><code>tee</code> takes data from stdin and sends it to zero or more files as well as stdout. Another way to write this would be <code>tee response.json</code></li>
</ul>
</li>
<li><code>pbcopy</code> - Copy the body to the clipboard (MacOS only - search online to find the correct command for your platform)</li>
</ul>
<p>Remember: This is a real shell, so you can pipe through whatever transformation commands you want here!</p>
<h2 id="default-command"><a class="header" href="#default-command">Default command</a></h2>
<p>You can set the default command to query with via the <a href="user_guide/tui/../../api/configuration/index.html#commandsdefault_query"><code>commands.default_query</code></a> config field. This accepts either a single string to set it for all content types, or a <a href="user_guide/tui/../../api/configuration/mime.html">MIME map</a> to set different defaults based on the response content type. For example, to default to <code>jq</code> for all JSON responses:</p>
<pre><code class="language-yaml">commands:
  default_query:
    json: jq
</code></pre>
<h2 id="which-shell-does-slumber-use"><a class="header" href="#which-shell-does-slumber-use">Which shell does Slumber use?</a></h2>
<p>By default, Slumber executes your command via <code>sh -c</code> on Unix and <code>cmd /S /C</code> on Windows. You can customize this via the <a href="user_guide/tui/../../api/configuration/index.html#commandsshell"><code>commands.shell</code> configuration field</a>. For example, to use <code>fish</code> instead of <code>sh</code>:</p>
<pre><code class="language-yaml">commands:
  shell: [fish, -c]
</code></pre>
<p>If you don't want to execute via <em>any</em> shell, you can set it to <code>[]</code>. In this case, query commands will be parsed via <a href="https://docs.rs/shell-words/latest/shell_words/">shell-words</a> and executed directly. For example, <code>jq .args</code> will be parsed into <code>["jq", ".args"]</code>, then <code>jq</code> will be executed with a single argument: <code>.args</code>. This of course means you won't get access to shell features such as <code>|</code>, but it provides better cross-platform portability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface"><a class="header" href="#command-line-interface">Command Line Interface</a></h1>
<p>While Slumber is primary intended as a TUI, it also provides a Command Line Interface (CLI). The CLI can be used to send requests, just like the TUI. It also provides some utility commands for functionality not available in the TUI. For a full list of available commands see the side bar or run:</p>
<pre><code class="language-sh">slumber help
</code></pre>
<p>Some common CLI use cases:</p>
<ul>
<li><a href="user_guide/cli/./subcommands.html#slumber-request">Send requests</a></li>
<li><a href="user_guide/cli/./subcommands.html#slumber-import">Import from an external format</a></li>
<li><a href="user_guide/cli/./subcommands.html#slumber-generate">Generate request in an external format (e.g. curl)</a></li>
<li><a href="user_guide/cli/./subcommands.html#slumber-show">View Slumber configuration/metadata</a></li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>The Slumber CLI can be composed with other CLI tools, making it a powerful tool for scripting and bulk tasks. Here are some examples of how to use it with common tools.</p>
<blockquote>
<p>Note: These examples are written for a POSIX shell (bash, zsh, etc.). It assumes some basic familiarity with shell features such as pipes. Unfortunately I have no shell experience with Windows so I can't help you there :(</p>
</blockquote>
<h3 id="filtering-responses-with-jq"><a class="header" href="#filtering-responses-with-jq">Filtering responses with <code>jq</code></a></h3>
<p>Let's say you want to fetch the name of each fish from your fish-tracking service. Here's your collection file:</p>
<pre><code class="language-yaml">requests:
  list_fish:
    method: GET
    url: "https://myfishes.fish/fishes"
</code></pre>
<p>This endpoint returns a response like:</p>
<pre><code class="language-json">[
  {
    "kind": "barracuda",
    "name": "Jimmy"
  },
  {
    "kind": "striped bass",
    "name": "Balthazar"
  },
  {
    "kind": "rockfish",
    "name": "Maureen"
  }
]
</code></pre>
<p>You can fetch this response and filter it down to just the names:</p>
<pre><code class="language-sh">slumber rq list_fish | jq -r '.[].name'
</code></pre>
<p>And the output:</p>
<pre><code>Jimmy
Balthazar
Maureen
</code></pre>
<h3 id="running-requests-in-parallel-with-xargs"><a class="header" href="#running-requests-in-parallel-with-xargs">Running requests in parallel with <code>xargs</code></a></h3>
<p>Building on <a href="user_guide/cli/index.html#filtering-responses-with-jq">the previous example</a>, let's say you want to fetch details on each fish returned from the list response. We'll add a <code>get_fish</code> recipe to the collection. By default, the fish name will come from a prompt:</p>
<pre><code class="language-yaml">profiles:
  prd:
    fish_name: "{{ prompt(message='Which fish?') }}"

requests:
  list_fish:
    method: GET
    url: "https://myfishes.fish/fishes"

  get_fish:
    method: GET
    url: "https://myfishes.fish/fishes/{{ fish_name }}"
</code></pre>
<p>We can use <code>xargs</code> and the <code>-o</code> flag of <code>slumber request</code> to fetch details for each fish in parallel:</p>
<pre><code class="language-sh">slumber rq list_fish | jq -r '.[].name' &gt; fish.txt
cat fish.txt | xargs -L1 -I'{}' -P3 slumber rq get_fish --override fish_name={} --output {}.json
</code></pre>
<p>Let's break this down:</p>
<ul>
<li><code>-L1</code> means to consume one argument (in this case, one fish name) per invocation of <code>slumber</code></li>
<li><code>-I{}</code> sets the substitution string, i.e. the string that will be replaced with each argument</li>
<li><code>-P3</code> tells <code>xargs</code> the maximum number of processes to run concurrently, which in this case means the maximum number of concurrent requests</li>
<li>Everything else is the <code>slumber</code> command
<ul>
<li><code>--override fish_name={}</code>: <code>xargs</code> replaces <code>fish_name</code> with the argument from the file, so it doesn't prompt for a name</li>
<li><code>--output {}.json</code> writes to a JSON file with the fish's name (e.g. <code>Jimmy.json</code>)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subcommands"><a class="header" href="#subcommands">Subcommands</a></h1>
<h2 id="slumber-collections"><a class="header" href="#slumber-collections"><code>slumber collections</code></a></h2>
<p>View and manipulate stored collection history/state. Slumber uses a local database to store all request/response history, as well as UI state and other persisted values. <strong>As a user, you rarely have to worry about this.</strong> The most common scenario in which you <em>do</em> have to is if you've renamed a collection file and want to migrate the history to match the new path. <a href="user_guide/cli/../database.html#migrating-collections">See here for how to migrate collection files</a>.</p>
<p>See <code>slumber collections --help</code> for more options.</p>
<h2 id="slumber-db"><a class="header" href="#slumber-db"><code>slumber db</code></a></h2>
<p>Access the local Slumber database file. This is an advanced command; most users never need to manually view or modify the database file. By default this executes <code>sqlite3</code> and thus requires <code>sqlite3</code> to be installed.</p>
<p>Open a shell to the database:</p>
<pre><code>slumber db
</code></pre>
<p>Run a single query and exit:</p>
<pre><code>slumber db 'select 1'
</code></pre>
<h2 id="slumber-generate"><a class="header" href="#slumber-generate"><code>slumber generate</code></a></h2>
<p>Generate an HTTP request in an external format. Currently the only supported format is cURL.</p>
<p><strong>Overrides</strong></p>
<p>The <code>generate</code> subcommand supports overriding template values in the same that <code>slumber request</code> does. See the <a href="user_guide/cli/subcommands.html#slumber-request"><code>request</code> subcommand docs</a> for more.</p>
<p>See <code>slumber generate --help</code> for more options.</p>
<p><strong>Examples</strong></p>
<p>Given this request collection:</p>
<pre><code class="language-yaml">profiles:
  production:
    data:
      host: https://myfishes.fish

requests:
  list_fish:
    method: GET
    url: "{{ host }}/fishes"
    query:
      big: true
</code></pre>
<pre><code class="language-sh">slumber generate curl --profile production list_fishes
slumber generate curl --profile production list_fishes -o host=http://localhost:8000
</code></pre>
<h2 id="slumber-history"><a class="header" href="#slumber-history"><code>slumber history</code></a></h2>
<p>View and modify your Slumber request history. Slumber stores every command sent <strong>from the TUI</strong> in a local SQLite database (requests are <strong>not</strong> stored remotely). You can find the database file with <code>slumber show paths db</code>.</p>
<p>You can use the <code>slumber history</code> subcommand to browse and delete request history.</p>
<h3 id="slumber-history-list"><a class="header" href="#slumber-history-list"><code>slumber history list</code></a></h3>
<p>List requests in a table.</p>
<pre><code class="language-sh">slumber history list # List all requests for the current collection
slumber history list --all # List all requests for all collections
slumber history list login # List all requests for the "login" recipe
slumber history list login -p dev # List all requests for "login" under the "dev" profile
</code></pre>
<h3 id="slumber-history-get"><a class="header" href="#slumber-history-get"><code>slumber history get</code></a></h3>
<p>Show a single request/response from history.</p>
<pre><code class="language-sh">slumber history get login # Get the most recent request/response for "login"
slumber history get 548ba3e7-3b96-4695-9856-236626ea0495 # Get a particular request/response by ID (IDs can be retrieved from the `list` subcommand)
</code></pre>
<h3 id="slumber-history-delete"><a class="header" href="#slumber-history-delete"><code>slumber history delete</code></a></h3>
<p>Delete requests from history by ID.</p>
<pre><code class="language-sh">slumber history delete 548ba3e7-3b96-4695-9856-236626ea0495
# Delete multiple requests
slumber history list login --id-only | xargs slumber history delete
</code></pre>
<h2 id="slumber-import"><a class="header" href="#slumber-import"><code>slumber import</code></a></h2>
<p>Generate a Slumber collection file based on an external format.</p>
<p>See <code>slumber import --help</code> for more options.</p>
<p><strong>Disclaimer</strong></p>
<p>Importers are <strong>approximate</strong>. They'll give the you skeleton of a collection file, but don't expect 100% equivalency. They save a lot of tedious work for you, but you'll generally still need to do some manual work on the collection file to get what you want.</p>
<p><strong>Formats</strong></p>
<p>Supported formats:</p>
<ul>
<li>Insomnia</li>
<li><a href="https://spec.openapis.org/oas/v3.0.3">OpenAPI v3.0</a> and <a href="https://spec.openapis.org/oas/v3.1.1.html">OpenAPI v3.1</a></li>
<li><a href="https://github.com/Huachao/vscode-restclient">VSCode <code>.rest</code></a></li>
<li><a href="https://www.jetbrains.com/help/idea/http-client-in-product-code-editor.html">JetBrains <code>.http</code></a></li>
</ul>
<p><strong>Examples</strong></p>
<p>The general format is:</p>
<pre><code class="language-sh">slumber import &lt;format&gt; &lt;input&gt; [output]
</code></pre>
<p>Possible inputs are:</p>
<ul>
<li><code>-</code> for stdin</li>
<li>Path to a local file</li>
<li>URL to download via HTTP</li>
</ul>
<p>For example, to import from an Insomnia collection <code>insomnia.json</code>:</p>
<pre><code class="language-sh">slumber import insomnia insomnia.json slumber.yml
# Or, to read from stdin and print to stdout
slumber import insomnia - &lt; insomnia.json
</code></pre>
<p>Or to import an OpenAPI spec from a server:</p>
<pre><code class="language-sh">slumber import openapi https://petstore3.swagger.io/api/v3/openapi.json slumber.yml
</code></pre>
<p>Requested formats:</p>
<ul>
<li><a href="https://github.com/LucasPickering/slumber/issues/417">Postman</a></li>
</ul>
<p>If you'd like another format supported, please <a href="https://github.com/LucasPickering/slumber/issues/new">open an issue</a>.</p>
<h2 id="slumber-new"><a class="header" href="#slumber-new"><code>slumber new</code></a></h2>
<p>Generate a new Slumber collection file. The new collection will have some example data predefined.</p>
<p><strong>Examples</strong></p>
<pre><code class="language-sh"># Generate and use a new collection at the default path of slumber.yml
slumber new
slumber

# Generate and use a new collection at a custom path
slumber new my-collection.yml
slumber -f my-collection.yml
</code></pre>
<h2 id="slumber-request"><a class="header" href="#slumber-request"><code>slumber request</code></a></h2>
<p>Send an HTTP request. There are many use cases to which the CLI is better suited than the TUI for sending requests, including:</p>
<ul>
<li>Sending a single one-off request</li>
<li>Sending many requests in parallel</li>
<li>Automating requests in a script</li>
<li>Sharing requests with others</li>
</ul>
<p>See <code>slumber request --help</code> for more options.</p>
<p><strong>Overrides</strong></p>
<p>You can manually override profile values using CLI arguments. This means the template renderer will use the override value in place of rendering the profile field. For example:</p>
<pre><code class="language-sh">slumber request list_fishes --override host=https://dev.myfishes.fish
</code></pre>
<p><strong>Exit Code</strong></p>
<p>By default, the CLI returns exit code 1 if there is a fatal error, e.g. the request failed to build or a network error occurred. If an HTTP response was received and parsed, the process will exit with code 0, regardless of HTTP status.</p>
<p>If you want to set the exit code based on the HTTP response status, use the flag <code>--exit-code</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Reason</th></tr></thead><tbody>
<tr><td>0</td><td>HTTP response received</td></tr>
<tr><td>1</td><td>Fatal error</td></tr>
<tr><td>2</td><td>HTTP response had status &gt;=400 (with <code>--exit-code</code>)</td></tr>
</tbody></table>
</div>
<p><strong>Examples</strong></p>
<p>Given this request collection:</p>
<pre><code class="language-yaml">profiles:
  production:
    data:
      host: https://myfishes.fish

requests:
  list_fish:
    method: GET
    url: "{{ host }}/fishes"
    query:
      big: true
</code></pre>
<pre><code class="language-sh">slumber request --profile production list_fishes
slumber rq -p production list_fishes # rq is a shorter alias
slumber -f fishes.yml -p production list_fishes # Different collection file
</code></pre>
<h2 id="slumber-show"><a class="header" href="#slumber-show"><code>slumber show</code></a></h2>
<p>Print metadata about Slumber.</p>
<p>See <code>slumber show --help</code> for more options.</p>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">slumber show paths # Show paths of various Slumber data files/directories
slumber show config # Print global configuration
slumber show config --edit # Edit global configuration
slumber show collection # Print collection file
slumber show collection --edit # Edit collection file
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database--persistence"><a class="header" href="#database--persistence">Database &amp; Persistence</a></h1>
<blockquote>
<p>Note: This is an advanced feature. The vast majority of users can use Slumber all they want without even knowing the database exists.</p>
</blockquote>
<p>Slumber uses a <a href="https://www.sqlite.org/">SQLite</a> database to persist requests and responses. The database also stores UI state that needs to be persisted between sessions. This database exists exclusively on your device. <strong>The Slumber database is never uploaded to the cloud or shared in any way.</strong> Slumber does not make any network connections beyond the ones you define and execute yourself. You own your data; I don't want it.</p>
<p>Data for all your Slumber collections are stored in a single file. To find this file, run <code>slumber show paths</code>, and look for the <code>Database</code> entry. I encourage you to browse this file if you're curious; it's pretty simple and there's nothing secret in it. Keep in mind though that <strong>the database format is NOT considered part of Slumber's API contract.</strong> It may change at any time, including the database path moving or tables be changed or removed, even in a minor or patch release.</p>
<h3 id="controlling-persistence"><a class="header" href="#controlling-persistence">Controlling Persistence</a></h3>
<p>By default, all requests made in the TUI are stored in the database. This enables the history browser, allowing you to browse past requests. While generally useful, this may not be desired in all cases. However, there are some cases where you may not want requests persisted:</p>
<ul>
<li>The request or response may contain sensitive data</li>
<li>The response is very large and impacts app performance</li>
</ul>
<p>You can disable persistence for a single recipe by setting <code>persist: false</code> <a href="user_guide/../api/request_collection/request_recipe.html#recipe-fields">for that recipe</a>. You can disable history globally by setting <code>persist: false</code> in the <a href="user_guide/../api/configuration/index.html">global config file</a>. Note that this only disables <em>request</em> persistence. UI state, such as selection state for panes and checkboxes, is still written to the database.</p>
<blockquote>
<p><strong>NOTE:</strong> Disabling persistence does <em>not</em> delete existing request history. <a href="user_guide/database.html#deleting-request-history">See here</a> for how to do that.</p>
</blockquote>
<p>Slumber will generally continue to work just fine with request persistence disabled. Requests and responses are still cached in memory, they just aren't written to the database anymore and therefore can't be recovered after the current session is closed. If you disable persistence, you will notice a few impacts on functionality:</p>
<ul>
<li>The history modal will only show requests made during the current session</li>
<li>Chained requests can only access responses from the current session. <a href="user_guide/../api/template_functions.html#response">Consider adding <code>trigger="no_history"</code> to the <code>response</code> call</a> to automatically refetch it on new sessions.</li>
</ul>
<p>Unlike the TUI, requests made from the CLI are <em>not</em> persisted by default. This is because the CLI is often used for scripting and bulk requests. Persisting these requests could have major performance impacts for little to no practical gain. Pass the <code>--persist</code> flag to <code>slumber request</code> to persist a CLI request.</p>
<h3 id="deleting-request-history"><a class="header" href="#deleting-request-history">Deleting Request History</a></h3>
<p>There are a few ways to delete requests from history:</p>
<ul>
<li>In the TUI. Open the actions menu while a request/response is selected to delete that request. From the recipe list/recipe pane, you can delete all requests for that recipe.</li>
<li><code>slumber history delete</code> can delete one or more commands at a time. Combine with <code>slumber history list</code> for bulk deletes: <code>slumber history list login --id-only | xargs slumber history delete</code></li>
<li><code>slumber collections delete</code> can delete all history for a single collection. If you have an old collection that you no longer use, you can delete it from the list using this command. <strong>Note:</strong> If you moved a collection file and want to remove the old file's history, you can also <a href="user_guide/database.html#migrating-collections">migrate the history to the new file location</a>.</li>
<li>Manually modifying the database. You can access the DB with <code>slumber db</code>. While this is not an officially supported technique (as the DB schema may change without warning), it's simple enough to navigate if you want to performance bulk deletes with custom criteria.</li>
</ul>
<h3 id="migrating-collections"><a class="header" href="#migrating-collections">Migrating Collections</a></h3>
<p>As all Slumber collections' histories are stored in the same SQLite database, each collection gets a unique <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a> generated when it is first accessed. This UUID is used to persist request history and other data related to the collection. This UUID is bound to the collection's path. If you move a collection file, a new UUID will be generated and it will be unlinked from its previous history. If you want to retain that history, you can migrate data from the old ID to the new one like so:</p>
<pre><code class="language-sh">slumber collections migrate slumber-old.yml slumber-new.yml
</code></pre>
<p>If you don't remember the path of the old file, you can list all known collections with:</p>
<pre><code class="language-sh">slumber collections list
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-schema-completion--validation"><a class="header" href="#json-schema-completion--validation">JSON Schema: Completion &amp; Validation</a></h1>
<p>Slumber generates a publishes a <a href="https://json-schema.org/">JSON Schema</a> for both the <a href="user_guide/../api/configuration/index.html">Config</a> and <a href="user_guide/../api/request_collection/index.html">Collection</a> formats. These are published via the <a href="https://github.com/LucasPickering/slumber">git repository</a> and are accessible at:</p>
<ul>
<li><a href="https://raw.githubusercontent.com/LucasPickering/slumber/refs/tags/0.0.1/schemas/config.json">config.json</a></li>
<li><a href="https://raw.githubusercontent.com/LucasPickering/slumber/refs/tags/0.0.1/schemas/collection.json">collection.json</a></li>
</ul>
<blockquote>
<p>Replace <code>0.0.1</code> with the version of Slumber you use for the most accurate schema definitions.</p>
</blockquote>
<h2 id="ide-completion"><a class="header" href="#ide-completion">IDE Completion</a></h2>
<p>Most IDEs use <a href="https://github.com/redhat-developer/yaml-language-server">yaml-language-server</a> for YAML highlighting and validation. This server supports additional validation with custom JSON schemas. To enable this, add this comment to the top of your config or collection file:</p>
<pre><code class="language-yaml"># yaml-language-server: $schema=&lt;url from above&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="request-collection-1"><a class="header" href="#request-collection-1">Request Collection</a></h1>
<p>The request collection is the primary configuration for Slumber. It defines which requests can be made, and how to make them. When running a <code>slumber</code> instance, a single collection file is loaded. If you want to work with multiple collections at once, you'll have to run multiple instances of Slumber.</p>
<p>Collection files are designed to be sharable, meaning you can commit them to your Git repo. The most common pattern is to create one collection per API repo, and check it into the repo so other developers of the API can use the same collection. This makes it easy for any new developer or user to learn how to use an API.</p>
<h2 id="format--loading"><a class="header" href="#format--loading">Format &amp; Loading</a></h2>
<p>A collection is defined as a <a href="https://yaml.org/">YAML</a> file. When you run <code>slumber</code>, it will search the current directory <em>and its parents</em> for the following default collection files, in order:</p>
<ul>
<li><code>slumber.yml</code></li>
<li><code>slumber.yaml</code></li>
<li><code>.slumber.yml</code></li>
<li><code>.slumber.yaml</code></li>
</ul>
<p>Whichever of those files is found <em>first</em> will be used. For any given directory, if no collection file is found there, it will recursively go up the directory tree until we find a collection file or hit the root directory. If you want to use a different file for your collection (e.g. if you want to store multiple collections in the same directory), you can override the auto-search with the <code>--file</code> (or <code>-f</code>) command line argument. You can also pass a directory to <code>--file</code> to have it search that directory instead of the current one. E.g.:</p>
<pre><code class="language-sh">slumber --file my-collection.yml
slumber --file ../another-project/
</code></pre>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>A request collection supports the following top-level fields:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>name</code></td><td><code>string</code></td><td>Descriptive name for the collection</td><td><code>""</code></td></tr>
<tr><td><code>profiles</code></td><td><a href="api/request_collection/./profile.html"><code>mapping[string, Profile]</code></a></td><td>Static template values</td><td><code>{}</code></td></tr>
<tr><td><code>requests</code></td><td><a href="api/request_collection/./request_recipe.html"><code>mapping[string, RequestRecipe]</code></a></td><td>Requests Slumber can send</td><td><code>{}</code></td></tr>
</tbody></table>
</div>
<p>In addition to these fields, any top-level field beginning with <code>.</code> will be ignored. This can be combined with <a href="api/request_collection/../../user_guide/composition.html">references</a> to define reusable components in your collection file.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<pre><code class="language-yaml"># Use YAML anchors for de-duplication. Normally unknown fields in the
# collection trigger an error; the . prefix tells Slumber to ignore this field
.base_profile:
  session_id: "{{ response('login') | jsonpath('$.id') }}"
  # User can select the fish ID from a list of IDs returned by /fish
  fish_id: "{{ response('list_fish') | jsonpath('$[*].id') | select() }}"

profiles:
  local:
    name: Local
    data:
      $ref: "#/.base_profile"
      host: http://localhost:5000
      user_guid: abc123
  prd:
    name: Production
    data:
      $ref: "#/.base_profile"
      host: https://shoal.lucaspickering.me
      user_guid: abc123

.base_request:
  headers:
    Accept: application/json
    Shoal-Session-ID: "{{ session_id }}"

requests:
  login:
    $ref: "#/.base_request"
    method: POST
    url: "{{ host }}/login"

  # Folders can be used to keep your recipes organized
  fish:
    name: Fish
    requests:
      list_fish:
        $ref: "#/.base_request"
        name: List Fish
        method: GET
        url: "{{ host }}/fish"

      update_fish:
        $ref: "#/.base_request"
        name: Update Fish
        method: PATCH
        url: "{{ host }}/fish/{{ fish_id }}"
        body:
          type: json
          data: { "name": "Kenny" }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="profile-1"><a class="header" href="#profile-1">Profile</a></h1>
<p>A profile is a collection of static template values. It's useful for configuring and switching between multiple different environments/settings/etc. Profile values are all templates themselves, so nested values can be used.</p>
<h2 id="fields-1"><a class="header" href="#fields-1">Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>name</code></td><td><code>string</code></td><td>Descriptive name to use in the UI</td><td>Value of key in parent</td></tr>
<tr><td><code>default</code></td><td><code>boolean</code></td><td>Use this profile in the CLI when <code>--profile</code> isn't provided</td><td><code>false</code></td></tr>
<tr><td><code>data</code></td><td><a href="api/request_collection/../../user_guide/templates/index.html"><code>mapping[string, Template]</code></a></td><td>Fields, mapped to their values</td><td><code>{}</code></td></tr>
</tbody></table>
</div>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<pre><code class="language-yaml">profiles:
  local:
    name: Local
    data:
      host: localhost:5000
      url: "https://{{ host }}"
      user_guid: abc123
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="request-recipe-1"><a class="header" href="#request-recipe-1">Request Recipe</a></h1>
<p>A request recipe defines how to make a particular request. For a REST API, you'll typically create one request recipe per endpoint. Other HTTP tools often call this just a "request", but that name can be confusing because "request" can also refer to a single instance of an HTTP request. Slumber uses the term "recipe" because it's used to render many requests. The word "template" would work as a synonym here, although we avoid that term here because it also refers to <a href="api/request_collection/../../user_guide/templates/index.html">string templates</a>.</p>
<p><strong>The IDs of your folders/recipes must be globally unique.</strong> This means you can't have two recipes (or two folders, or one recipe and one folder) with the same associated key, even if they are in different folders. This restriction makes it easy to refer to recipes unambiguously using a single ID, which is helpful for CLI usage and data storage.</p>
<blockquote>
<p>There is no need to explicitly declare whether a node is a folder or a recipe. Slumber infers based on the presence/absence of the <code>url</code> or <code>method</code> fields.</p>
</blockquote>
<h2 id="recipe-fields"><a class="header" href="#recipe-fields">Recipe Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>name</code></td><td><code>string</code></td><td>Descriptive name to use in the UI</td><td>Value of key in parent</td></tr>
<tr><td><code>method</code></td><td><code>string</code></td><td>HTTP request method</td><td>Required</td></tr>
<tr><td><code>url</code></td><td><a href="api/request_collection/../../user_guide/templates/index.html"><code>Template</code></a></td><td>HTTP request URL</td><td>Required</td></tr>
<tr><td><code>query</code></td><td><a href="api/request_collection/./query_parameters.html"><code>mapping[string, QueryParameterValue]</code></a></td><td>URL query parameters</td><td><code>{}</code></td></tr>
<tr><td><code>headers</code></td><td><a href="api/request_collection/../../user_guide/templates/index.html"><code>mapping[string, Template]</code></a></td><td>HTTP request headers</td><td><code>{}</code></td></tr>
<tr><td><code>authentication</code></td><td><a href="api/request_collection/./authentication.html"><code>Authentication</code></a></td><td>Authentication scheme</td><td><code>null</code></td></tr>
<tr><td><code>body</code></td><td><a href="api/request_collection/./recipe_body.html"><code>RecipeBody</code></a></td><td>HTTP request body</td><td><code>null</code></td></tr>
<tr><td><code>persist</code></td><td><code>boolean</code></td><td>Enable/disable request persistence. <a href="api/request_collection/../../user_guide/database.html">Read more</a></td><td><code>true</code></td></tr>
</tbody></table>
</div>
<h2 id="folder-fields"><a class="header" href="#folder-fields">Folder Fields</a></h2>
<p>Recipes can be organized into folders. This means your set of recipes can form a tree structure. Folders are purely organizational, and don't impact the behavior of their child recipes at all.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>name</code></td><td><code>string</code></td><td>Descriptive name to use in the UI</td><td>Value of key in parent</td></tr>
<tr><td><code>requests</code></td><td><a href="api/request_collection/./request_recipe.html"><code>mapping[string, RequestRecipe]</code></a></td><td>Recipes organized under this folder</td><td><code>{}</code></td></tr>
</tbody></table>
</div>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<pre><code class="language-yaml">requests:
  login:
    name: Login
    method: POST
    url: "{{ host }}/anything/login"
    headers:
      accept: application/json
    query:
      root_access: yes_please
    body:
      type: json
      data:
        {
          "username": "{{ command(['whoami']) }}",
          "password": "{{ prompt(message='Password', sensitive=true) }}",
        }
  fish:
    name: Users
    requests:
      create_fish:
        method: POST
        url: "{{ host }}/fishes"
        body:
          type: json
          data: { "kind": "barracuda", "name": "Jimmy" }

      list_fish:
        method: GET
        url: "{{ host }}/fishes"
        query:
          big: true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-parameters-1"><a class="header" href="#query-parameters-1">Query Parameters</a></h1>
<p>Query parameters are a component of a request URL. They provide additional information to the server about a request. In a request recipe, query parameters are defined as a map of <code>parameter: value</code>. The value can be a singular template (string/boolean/etc.) or a list of values.</p>
<pre><code class="language-yaml">query:
  one: value
  many: [value1, value2]
</code></pre>
<p>A single query parameter can repeat multiple times in a URL; The above example will generate the query string <code>?one=value&amp;many=value1&amp;many=value2</code>.</p>
<blockquote>
<p>Note: Prior to version 4.0, Slumber supported a string-based query parameter format like <code>[one=value, many=value1, many=value2]</code>. To migrate your collection file, see <a href="api/request_collection/../../other/v4_migration.html">v3 to v4 Migration</a>.</p>
</blockquote>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<pre><code class="language-yaml">recipes:
  get_fishes:
    method: GET
    url: "{{ host }}/get"
    query:
      big: true
      color: [red, blue]
      name: "{{ name }}"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication-1"><a class="header" href="#authentication-1">Authentication</a></h1>
<p>Authentication provides shortcuts for common HTTP authentication schemes. It populates the <code>authentication</code> field of a recipe. There are multiple source types, and the type is specified using the <code>type</code> field.</p>
<h2 id="authentication-types"><a class="header" href="#authentication-types">Authentication Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Variant</th><th>Value</th></tr></thead><tbody>
<tr><td><code>basic</code></td><td><a href="api/request_collection/authentication.html#basic-authentication">Basic authentication</a></td></tr>
<tr><td><code>bearer</code></td><td><a href="api/request_collection/authentication.html#bearer-token">Bearer token</a></td></tr>
</tbody></table>
</div>
<h3 id="basic-authentication"><a class="header" href="#basic-authentication">Basic Authentication</a></h3>
<p><a href="https://swagger.io/docs/specification/authentication/basic-authentication/">Basic authentication</a> contains a username and optional password.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>username</code></td><td><code>string</code></td><td>Username</td><td>Required</td></tr>
<tr><td><code>password</code></td><td><code>string</code></td><td>Password</td><td><code>""</code></td></tr>
</tbody></table>
</div>
<h3 id="bearer-token"><a class="header" href="#bearer-token">Bearer Token</a></h3>
<p><a href="https://swagger.io/docs/specification/authentication/bearer-authentication/">Bearer token authentication</a> takes a single token.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>string</code></td><td>Token</td><td>Required</td></tr>
</tbody></table>
</div>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<pre><code class="language-yaml">requests:
  basic_auth:
    method: GET
    url: "{{host}}/fishes"
    authentication:
      type: basic
      username: user
      password: "{{ prompt() }}"

  bearer_auth:
    method: GET
    url: "{{host}}/fishes"
    authentication:
      type: bearer
      token: "{{ file('token.txt') }}"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipe-body"><a class="header" href="#recipe-body">Recipe Body</a></h1>
<p>There are a variety of ways to define the body of your request. Slumber supports structured bodies for a fixed set of known content types (see table below). In addition to handling body serialization for you, structured bodies will also set the <code>Content-Type</code> header.</p>
<p>In addition, you can pass any <a href="api/request_collection/../../user_guide/templates/index.html"><code>Template</code></a> to render any text or binary data. In this case, you'll probably want to explicitly set the <code>Content-Type</code> header to tell the server what kind of data you're sending. This may not be necessary though, depending on the server implementation.</p>
<h2 id="body-types"><a class="header" href="#body-types">Body Types</a></h2>
<p>The following content types have first-class support. Slumber will automatically set the <code>Content-Type</code> header to the specified value, but you can override this simply by providing your own value for the header.</p>
<div class="table-wrapper"><table><thead><tr><th>Variant</th><th><code>Content-Type</code></th><th>Description</th></tr></thead><tbody>
<tr><td><code>stream</code></td><td>None</td><td>Instead of rendering an entire body eagerly, stream the bytes of the template to the server as they're rendered; <a href="api/request_collection/../../user_guide/streaming.html">more info</a></td></tr>
<tr><td><code>json</code></td><td><code>application/json</code></td><td>Structured JSON body; all strings are treated as templates</td></tr>
<tr><td><code>form_urlencoded</code></td><td><code>application/x-www-form-urlencoded</code></td><td>URL-encoded form data; <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST">more info</a></td></tr>
<tr><td><code>form_multipart</code></td><td><code>multipart/form-data</code></td><td>Binary form data; <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST">more info</a></td></tr>
</tbody></table>
</div>
<h3 id="json"><a class="header" href="#json">JSON</a></h3>
<p>JSON bodies can contain any data. All strings in the JSON are treated as <a href="api/request_collection/../../user_guide/templates/index.html">templates</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>data</code></td><td>Any</td><td>JSON content</td><td>Required</td></tr>
</tbody></table>
</div>
<p>See <a href="api/request_collection/../../user_guide/recipes.html#body">the guide</a> for more detail on how to use JSON bodies.</p>
<h3 id="url-encoded-form"><a class="header" href="#url-encoded-form">URL-encoded Form</a></h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST">URL forms</a> can only pass text data.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>data</code></td><td><a href="api/request_collection/../../user_guide/templates/index.html"><code>mapping[string, Template]</code></a>`</td><td>Form fields</td><td>Required</td></tr>
</tbody></table>
</div>
<p>See <a href="api/request_collection/../../user_guide/recipes.html#body">the guide</a> for more detail on how to use form bodies.</p>
<h3 id="multipart-form"><a class="header" href="#multipart-form">Multipart Form</a></h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST">Multipart forms</a> can pass text or binary data.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>data</code></td><td><a href="api/request_collection/../../user_guide/templates/index.html"><code>mapping[string, Template]</code></a>`</td><td>Form fields</td><td>Required</td></tr>
</tbody></table>
</div>
<p>See <a href="api/request_collection/../../user_guide/recipes.html#body">the guide</a> for more detail on how to use form bodies, and <a href="api/request_collection/../../user_guide/streaming.html#multipart-file-streaming">Multipart File Streaming</a> for details on how data is streamed.</p>
<h2 id="examples-7"><a class="header" href="#examples-7">Examples</a></h2>
<pre><code class="language-yaml">requests:
  text_body:
    method: POST
    url: "{{ host }}/fishes/{{ fish_id }}/name"
    headers:
      Content-Type: text/plain
    body: Alfonso

  binary_body:
    method: POST
    url: "{{ host }}/fishes/{{ fish_id }}/image"
    headers:
      Content-Type: image/jpg
    body: "{{ file('./fish.png') }}"

  json_body:
    method: POST
    url: "{{ host }}/fishes/{{ fish_id }}"
    # Content-Type header will be set automatically based on the body type
    body:
      type: json
      data: { "name": "Alfonso" }

  urlencoded_body:
    method: POST
    url: "{{ host }}/fishes/{{ fish_id }}"
    # Content-Type header will be set automatically based on the body type
    body:
      type: form_urlencoded
      data:
        name: Alfonso

  multipart_body:
    method: POST
    url: "{{ host }}/fishes/{{ fish_id }}"
    # Content-Type header will be set automatically based on the body type
    body:
      type: form_multipart
      data:
        name: Alfonso
        image: "{{ file('./fish.png') }}"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>Configuration provides <em>global</em> settings for all of Slumber, as opposed to collection-level settings.</p>
<h2 id="location--creation"><a class="header" href="#location--creation">Location &amp; Creation</a></h2>
<p>By default, configuration is stored in a platform-specific configuration directory, according to <a href="https://docs.rs/dirs/latest/dirs/fn.config_dir.html">dirs::config_dir</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Path</th></tr></thead><tbody>
<tr><td>Linux</td><td><code>$HOME/.config/slumber/config.yml</code></td></tr>
<tr><td>MacOS</td><td><code>$HOME/Library/Application Support/slumber/config.yml</code></td></tr>
<tr><td>Windows</td><td><code>C:\Users\&lt;User&gt;\AppData\Roaming\slumber\config.yml</code></td></tr>
</tbody></table>
</div>
<p>You can also find the config path by running:</p>
<pre><code class="language-sh">slumber show paths config
</code></pre>
<p>You can open the config file in <a href="api/configuration/../../user_guide/tui/editor.html#editing">your preferred editor</a> with:</p>
<pre><code class="language-sh">slumber show config --edit
</code></pre>
<p>If the config directory doesn't exist yet, Slumber will create it automatically when starting the TUI for the first time.</p>
<blockquote>
<p>Note: Prior to version 2.1.0, Slumber stored configuration in a different location on Linux (<code>~/.local/share/slumber/config.yml</code>). If that file exists on your system, <strong>it will be used in place of the newer location.</strong> For more context, see <a href="https://github.com/LucasPickering/slumber/issues/371">issue #371</a>.</p>
</blockquote>
<p>You can change the location of the config file by setting the environment variable <code>SLUMBER_CONFIG_PATH</code>. For example:</p>
<pre><code class="language-sh">SLUMBER_CONFIG_PATH=~/dotfiles/slumber.yml slumber
</code></pre>
<h2 id="fields-2"><a class="header" href="#fields-2">Fields</a></h2>
<p>The following fields are available in <code>config.yml</code>:</p>
<h3 id="commandsshell"><a class="header" href="#commandsshell"><code>commands.shell</code></a></h3>
<p><strong>Type:</strong> <code>string[]</code></p>
<p><strong>Default:</strong> <code>[sh, -c]</code> (Unix), <code>[cmd, /S, /C]</code> (Windows)</p>
<p>Shell used to execute commands within the TUI. Use <code>[]</code> for no shell (commands will be parsed and executed directly). <a href="api/configuration/../../user_guide/tui/filter_query.html">More info</a></p>
<h3 id="commandsdefault_query"><a class="header" href="#commandsdefault_query"><code>commands.default_query</code></a></h3>
<p><strong>Type:</strong> <code>string</code> or <code>mapping[Mime, string]</code> (see <a href="api/configuration/./mime.html">MIME Maps</a>)</p>
<p><strong>Default:</strong> <code>""</code></p>
<p>Default query command for all responses. <a href="api/configuration/../../user_guide/tui/filter_query.html">More info</a></p>
<h3 id="editor"><a class="header" href="#editor"><code>editor</code></a></h3>
<p><strong>Type:</strong> <code>string</code></p>
<p><strong>Default:</strong> <code>VISUAL</code>/<code>EDITOR</code> env vars, or <code>vim</code></p>
<p>Command to use when opening files for in-app editing. <a href="api/configuration/../../user_guide/tui/editor.html#editing">More info</a></p>
<h3 id="follow_redirects"><a class="header" href="#follow_redirects"><code>follow_redirects</code></a></h3>
<p><strong>Type:</strong> <code>boolean</code></p>
<p><strong>Default:</strong> <code>true</code></p>
<p>Enable/disable following redirects (3xx status codes) automatically. If enabled, the HTTP client follow redirects <a href="https://docs.rs/reqwest/0.12.15/reqwest/index.html#redirect-policies">up to 10 times</a>.</p>
<h3 id="ignore_certificate_hosts"><a class="header" href="#ignore_certificate_hosts"><code>ignore_certificate_hosts</code></a></h3>
<p><strong>Type:</strong> <code>string</code></p>
<p><strong>Default:</strong> <code>[]</code></p>
<p>Hostnames whose TLS certificate errors will be ignored. <a href="api/configuration/../../troubleshooting/tls.html">More info</a></p>
<h3 id="input_bindings"><a class="header" href="#input_bindings"><code>input_bindings</code></a></h3>
<p><strong>Type:</strong> <code>mapping[Action, KeyCombination[]]</code></p>
<p><strong>Default:</strong> <code>{}</code></p>
<p>Override default input bindings. <a href="api/configuration/./input_bindings.html">More info</a></p>
<h3 id="large_body_size"><a class="header" href="#large_body_size"><code>large_body_size</code></a></h3>
<p><strong>Type:</strong> <code>number</code></p>
<p><strong>Default:</strong> <code>1000000</code> (1 MB)</p>
<p>Size over which request/response bodies are not formatted/highlighted, for performance (bytes)</p>
<h3 id="persist"><a class="header" href="#persist"><code>persist</code></a></h3>
<p><strong>Type:</strong> <code>boolean</code></p>
<p><strong>Default:</strong> <code>true</code></p>
<p>Enable/disable the storage of requests and responses in Slumber's local database. This is only used in the TUI. CLI requests are <em>not</em> persisted unless the <code>--persist</code> flag is passed, in which case they will always be persisted. <a href="api/configuration/../../user_guide/database.html">See here for more</a>.</p>
<h3 id="preview_templates"><a class="header" href="#preview_templates"><code>preview_templates</code></a></h3>
<p><strong>Type:</strong> <code>boolean</code></p>
<p><strong>Default:</strong> <code>true</code></p>
<p>Render template values in the TUI? If false, the raw template will be shown.</p>
<h3 id="theme"><a class="header" href="#theme"><code>theme</code></a></h3>
<p><strong>Type:</strong> <code>Theme</code></p>
<p><strong>Default:</strong> <code>{}</code></p>
<p>Visual customizations for the TUI. <a href="api/configuration/./theme.html">More info</a></p>
<h3 id="pager"><a class="header" href="#pager"><code>pager</code></a></h3>
<p><strong>Alias:</strong> <code>viewer</code> (for historical compatibility)</p>
<p><strong>Type:</strong> <code>string</code> or <code>mapping[Mime, string]</code> (see <a href="api/configuration/./mime.html">MIME Maps</a>)</p>
<p><strong>Default:</strong> <code>less</code> (Unix), <code>more</code> (Windows)</p>
<p>Command to use when opening files for viewing. <a href="api/configuration/../../user_guide/tui/editor.html#paging">More info</a></p>
<h3 id="ignored-fields"><a class="header" href="#ignored-fields">Ignored Fields</a></h3>
<p>In addition to the above fields, any top-level field beginning with <code>.</code> will be ignored. This can be combined with <a href="https://yaml.org/spec/1.2.2/#anchors-and-aliases">YAML anchors</a> to define reusable components in your config file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-bindings"><a class="header" href="#input-bindings">Input Bindings</a></h1>
<p>You can customize all input bindings in the configuration. An input binding is a mapping between an action (a high-level verb) and one or more key combinations.</p>
<p>For example if you want vim bindings (h/j/k/l instead of left/down/up/right):</p>
<pre><code class="language-yaml"># config.yaml
input_bindings:
  up: [k]
  down: [j]
  left: [h]
  right: [l]
  scroll_left: [shift h]
  scroll_right: [shift l]
  select_recipe_list: [w] # Rebind from `l`
</code></pre>
<p>Each action maps to a <em>list</em> of key combinations, because you can map multiple combinations to a single action. Hitting any of these combinations will trigger the action. By defining a binding in the config, <strong>you will replace the default binding for that action</strong>. If you want to retain the default binding but add an additional, you will need to include the default in your list of custom bindings. For example, if you want vim bindings but also want to leave the existing arrow key controls in place:</p>
<pre><code class="language-yaml">input_bindings:
  up: [up, k]
  down: [down, j]
  left: [left, h]
  right: [right, l]
  scroll_left: [shift left, shift h]
  scroll_right: [shift right, shift l]
  select_recipe_list: [w] # Rebind from `l`
</code></pre>
<h2 id="actions"><a class="header" href="#actions">Actions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Action</th><th>Default Binding</th><th>Description</th></tr></thead><tbody>
<tr><td><code>left_click</code></td><td>None</td><td></td></tr>
<tr><td><code>right_click</code></td><td>None</td><td></td></tr>
<tr><td><code>scroll_up</code></td><td>None</td><td></td></tr>
<tr><td><code>scroll_down</code></td><td>None</td><td></td></tr>
<tr><td><code>scroll_left</code></td><td><code>shift left</code></td><td></td></tr>
<tr><td><code>scroll_right</code></td><td><code>shift right</code></td><td></td></tr>
<tr><td><code>quit</code></td><td><code>q</code></td><td>Exit current dialog, or the entire app</td></tr>
<tr><td><code>force_quit</code></td><td><code>ctrl c</code></td><td>Exit the app, regardless</td></tr>
<tr><td><code>previous_pane</code></td><td><code>shift tab</code></td><td>Select previous pane in the cycle</td></tr>
<tr><td><code>next_pane</code></td><td><code>tab</code></td><td></td></tr>
<tr><td><code>up</code></td><td><code>up</code></td><td></td></tr>
<tr><td><code>down</code></td><td><code>down</code></td><td></td></tr>
<tr><td><code>left</code></td><td><code>left</code></td><td></td></tr>
<tr><td><code>right</code></td><td><code>right</code></td><td></td></tr>
<tr><td><code>page_up</code></td><td><code>pgup</code></td><td></td></tr>
<tr><td><code>page_down</code></td><td><code>pgdn</code></td><td></td></tr>
<tr><td><code>home</code></td><td><code>home</code></td><td></td></tr>
<tr><td><code>end</code></td><td><code>end</code></td><td></td></tr>
<tr><td><code>submit</code></td><td><code>enter</code></td><td>Send a request, submit a text box, etc.</td></tr>
<tr><td><code>toggle</code></td><td><code>space</code></td><td>Toggle a checkbox on/off</td></tr>
<tr><td><code>cancel</code></td><td><code>esc</code></td><td>Cancel current dialog or request</td></tr>
<tr><td><code>delete</code></td><td><code>delete</code></td><td>Delete the selected object (e.g. a request)</td></tr>
<tr><td><code>edit</code></td><td><code>e</code></td><td>Apply a temporary override to a recipe value</td></tr>
<tr><td><code>reset</code></td><td><code>r</code></td><td>Reset temporary recipe override to its default</td></tr>
<tr><td><code>view</code></td><td><code>v</code></td><td>Open the selected content (e.g. body) in your pager</td></tr>
<tr><td><code>history</code></td><td><code>h</code></td><td>Open request history for a recipe</td></tr>
<tr><td><code>search</code></td><td><code>/</code></td><td>Open/select search for current pane</td></tr>
<tr><td><code>export</code></td><td><code>:</code></td><td>Enter command for exporting response data</td></tr>
<tr><td><code>reload_collection</code></td><td><code>f5</code></td><td>Force reload collection file</td></tr>
<tr><td><code>fullscreen</code></td><td><code>f</code></td><td>Fullscreen current pane</td></tr>
<tr><td><code>open_actions</code></td><td><code>x</code></td><td>Open actions menu</td></tr>
<tr><td><code>open_help</code></td><td><code>?</code></td><td>Open help dialog</td></tr>
<tr><td><code>select_collection</code></td><td><code>f3</code></td><td>Open collection select dialog</td></tr>
<tr><td><code>select_profile_list</code></td><td><code>p</code></td><td>Open Profile List dialog</td></tr>
<tr><td><code>select_recipe_list</code></td><td><code>l</code></td><td>Select Recipe List pane</td></tr>
<tr><td><code>select_recipe</code></td><td><code>c</code></td><td>Select Recipe pane</td></tr>
<tr><td><code>select_response</code></td><td><code>s</code></td><td>Select Request/Response pane</td></tr>
<tr><td><code>select_request</code></td><td><code>r</code></td><td>Select Request/Response pane (backward compatibility)</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Note: mouse bindings are not configurable; mouse actions such as <code>left_click</code> <em>can</em> be bound to a key combination, which cannot be unbound from the default mouse action.</p>
</blockquote>
<h2 id="key-combinations"><a class="header" href="#key-combinations">Key Combinations</a></h2>
<p>A key combination consists of zero or more modifiers, followed by a single key code. The modifiers and the code all each separated by a single space. Some examples:</p>
<ul>
<li><code>w</code></li>
<li><code>shift f2</code></li>
<li><code>alt shift c</code></li>
<li><code>ctrl alt delete</code></li>
</ul>
<h3 id="key-codes"><a class="header" href="#key-codes">Key Codes</a></h3>
<p>All single-character keys (e.g. <code>w</code>, <code>/</code>, <code>=</code>, etc.) are not listed; the code is just the character.</p>
<ul>
<li><code>escape</code>/<code>esc</code></li>
<li><code>enter</code></li>
<li><code>left</code></li>
<li><code>right</code></li>
<li><code>up</code></li>
<li><code>down</code></li>
<li><code>home</code></li>
<li><code>end</code></li>
<li><code>pageup</code>/<code>pgup</code></li>
<li><code>pagedown</code>/<code>pgdn</code></li>
<li><code>tab</code></li>
<li><code>backtab</code> (equivalent to <code>shift tab</code>, supported for backward compatibility)</li>
<li><code>backspace</code></li>
<li><code>delete</code>/<code>del</code></li>
<li><code>insert</code>/<code>ins</code></li>
<li><code>capslock</code>/<code>caps</code></li>
<li><code>scrolllock</code></li>
<li><code>numlock</code></li>
<li><code>printscreen</code></li>
<li><code>pausebreak</code> (sometimes just called Pause; <em>not</em> the same as the Pause media key)</li>
<li><code>menu</code></li>
<li><code>keypadbegin</code></li>
<li><code>f1</code></li>
<li><code>f2</code></li>
<li><code>f3</code></li>
<li><code>f4</code></li>
<li><code>f5</code></li>
<li><code>f6</code></li>
<li><code>f7</code></li>
<li><code>f8</code></li>
<li><code>f9</code></li>
<li><code>f10</code></li>
<li><code>f11</code></li>
<li><code>f12</code></li>
<li><code>space</code></li>
<li><code>play</code></li>
<li><code>pause</code> (the media key, <em>not</em> Pause/Break)</li>
<li><code>playpause</code></li>
<li><code>reverse</code></li>
<li><code>stop</code></li>
<li><code>fastforward</code></li>
<li><code>rewind</code></li>
<li><code>tracknext</code></li>
<li><code>trackprevious</code></li>
<li><code>record</code></li>
<li><code>lowervolume</code></li>
<li><code>raisevolume</code></li>
<li><code>mute</code></li>
</ul>
<h3 id="key-modifiers"><a class="header" href="#key-modifiers">Key Modifiers</a></h3>
<ul>
<li><code>shift</code></li>
<li><code>alt</code></li>
<li><code>ctrl</code></li>
<li><code>super</code></li>
<li><code>hyper</code></li>
<li><code>meta</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mime-maps"><a class="header" href="#mime-maps">MIME Maps</a></h1>
<p>Some configuration fields support a mapping of <a href="https://en.wikipedia.org/wiki/Media_type">MIME types</a> (AKA media types or content types). This allow you to set multiple values for the configuration field, and the correct value will be selected based on the MIME type of the relevant recipe/request/response.</p>
<p>The keys of this map are glob-formatted (i.e. wildcard) MIME types. For example, if you're configuring your pager and you want to use <code>hexdump</code> for all images, <code>fx</code> for JSON, and <code>less</code> for everything else:</p>
<pre><code class="language-yaml">pager:
  image/*: hexdump
  application/json: fx
  "*/*": less
</code></pre>
<blockquote>
<p><strong>Note:</strong> Paths are matched top to bottom, so <code>*/*</code> <strong>should always go last</strong>. Any pattern starting with <code>*</code> must be wrapped in quotes in order to be parsed as a string.</p>
</blockquote>
<ul>
<li><code>image/png</code>: matches <code>image/*</code></li>
<li><code>image/jpeg</code>: matches <code>image/*</code></li>
<li><code>application/json</code>: matches <code>application/json</code></li>
<li><code>text/csv</code>: matches <code>*/*</code></li>
</ul>
<h2 id="aliases"><a class="header" href="#aliases">Aliases</a></h2>
<p>In addition to accepting MIME patterns, there are also predefined aliases to make common matches more convenient:</p>
<div class="table-wrapper"><table><thead><tr><th>Alias</th><th>Maps To</th></tr></thead><tbody>
<tr><td><code>default</code></td><td><code>*/*</code></td></tr>
<tr><td><code>json</code></td><td><code>application/*json</code></td></tr>
<tr><td><code>image</code></td><td><code>image/*</code></td></tr>
</tbody></table>
</div>
<h2 id="notes-on-matching"><a class="header" href="#notes-on-matching">Notes on Matching</a></h2>
<ul>
<li>Matching is done top to bottom, and <strong>the first matching pattern will be used</strong>. For this reason, your <code>*/*</code> pattern <strong>should always be last</strong>.</li>
<li>Matching is performed just against the <a href="https://docs.rs/mime/latest/mime/struct.Mime.html#method.essence_str">essence string</a> of the recipe/request/response's <code>Content-Type</code> header, i.e. the <code>type/subtype</code> only. In the example <code>multipart/form-data; boundary=ABCDEFG</code>, the semicolon and everything after it <strong>is not included in the match</strong>.</li>
<li>Matching is performed by the <a href="https://docs.rs/glob/latest/glob/struct.Pattern.html">Rust glob crate</a>. Despite being intended for matching file paths, it works well for MIME types too because they are also <code>/</code>-delimited</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="theme-1"><a class="header" href="#theme-1">Theme</a></h1>
<p>Theming allows you to customize the appearance of the Slumber TUI. To start, <a href="api/configuration/../configuration/index.html#location--creation">open up your configuration file</a> and add some theme settings:</p>
<pre><code class="language-yaml">theme:
  primary_color: green
  secondary_color: blue
</code></pre>
<h2 id="fields-3"><a class="header" href="#fields-3">Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>primary_color</code></td><td><code>Color</code></td><td>Color of most emphasized content</td></tr>
<tr><td><code>primary_text_color</code></td><td><code>Color</code></td><td>Color of text on top of the primary color (generally white or black)</td></tr>
<tr><td><code>secondary_color</code></td><td><code>Color</code></td><td>Color of secondary notable content</td></tr>
<tr><td><code>success_color</code></td><td><code>Color</code></td><td>Color representing successful events</td></tr>
<tr><td><code>error_color</code></td><td><code>Color</code></td><td>Color representing error messages</td></tr>
</tbody></table>
</div>
<h2 id="color-format"><a class="header" href="#color-format">Color Format</a></h2>
<p>Colors can be specified as names (e.g. "yellow"), RGB codes (e.g. <code>#ffff00</code>) or ANSI color indexes. See the <a href="https://docs.rs/ratatui/latest/ratatui/style/enum.Color.html#impl-FromStr-for-Color">Ratatui docs</a> for more details on color deserialization.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-functions"><a class="header" href="#template-functions">Template Functions</a></h1>
<h2 id="reading-function-signatures"><a class="header" href="#reading-function-signatures">Reading Function Signatures</a></h2>
<p>The function signatures below borrow from TypeScript to describe the arguments a function accepts and the value it returns:</p>
<pre><code class="language-typescript">f(arg1: boolean, arg2: string[], arg3?: string): bytes
</code></pre>
<p>The function <code>f</code> accepts two required positional arguments (<code>arg1</code> and <code>arg2</code>) and one optional keyword argument (<code>arg3</code>), and returns a <code>bytes</code>.</p>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<p><code>value</code> is the top-level type. It represents any <a href="api/../user_guide/templates/values.html">template value</a>.</p>
<p>The following types are scalar (i.e. not collections):</p>
<ul>
<li><code>boolean</code></li>
<li><code>float</code></li>
<li><code>integer</code></li>
<li><code>string</code></li>
<li><code>bytes</code></li>
</ul>
<p>Array types accept an array of a single type: <code>string[]</code> accepts <code>["a", "b", "c"]</code> but not <code>["a", 1, false]</code>.</p>
<p>Type unions allow values that match <em>any</em> of the members: <code>"a" | "b"</code> accepts the string <code>"a"</code> or the string <code>"b"</code>.</p>
<p>Some functions define custom types such as <code>JsonPath</code>, which are generally a narrowing of the <code>string</code> type. These will be described on a case-by-case basis in the function descriptions.</p>
<h3 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h3>
<p>Arguments with a <code>?</code> are optional keyword arguments. Those without <code>?</code> are required positional arguments. See <a href="api/../user_guide/templates/functions.html#arguments">Arguments</a> for more.</p>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<!-- Function docs are autogenerated. See crates/core/src/render/functions.rs -->
<h3 id="base64"><a class="header" href="#base64">base64</a></h3>
<pre><code class="language-typescript">base64(value: bytes, decode?: boolean): bytes
</code></pre>
<p>Encode or decode content to/from base64.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>decode</code>: Decode the input from base64 to its original value instead of
encoding it <em>to</em> base64</li>
</ul>
<p><strong>Errors</strong></p>
<ul>
<li>If <code>decode=true</code> and the string is not valid base64</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ base64("test") }} =&gt; "dGVzdA=="
{{ base64("dGVzdA==", decode=true) }} =&gt; "test"
</code></pre>
<h3 id="boolean"><a class="header" href="#boolean">boolean</a></h3>
<pre><code class="language-typescript">boolean(value: value): boolean
</code></pre>
<p>Convert a value to a boolean. Empty values such as <code>0</code>, <code>""</code> or <code>[]</code>
convert to <code>false</code>. Anything else converts to <code>true</code>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>value</code>: Value to convert</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ boolean(null) }} =&gt; false
{{ boolean(0) }} =&gt; false
{{ boolean(1) }} =&gt; true
{{ boolean('') }} =&gt; false
{{ boolean('0') }} =&gt; true
{{ boolean([]) }} =&gt; false
{{ boolean([0]) }} =&gt; true
</code></pre>
<h3 id="command"><a class="header" href="#command">command</a></h3>
<pre><code class="language-typescript">command(command: string[], cwd?: string, stdin?: bytes): bytes
</code></pre>
<p>Run a command in a subprocess and return its stdout output. While the output
type is <code>bytes</code>, <a href="api/../user_guide/templates/values.html#bytes-vs-string">in most cases you can use it interchangeably as a
string</a>.</p>
<p>This function supports <a href="api/../user_guide/streaming.html">streaming</a>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>command</code>: Command to run, in the form <code>[program, arg1, arg2, ...]</code></li>
<li><code>cwd</code>: Directory to execute the subprocess in. Defaults to the directory
containing the collection file. For example, if the collection is
<code>/data/slumber.yml</code>, the subprocess will execute in <code>/data</code> regardless of
where Slumber is invoked from. The given path will be resolved relative to
that default.</li>
<li><code>stdin</code>: Data to pipe to the subprocess's stdin</li>
</ul>
<p><strong>Errors</strong></p>
<ul>
<li>If the command fails to initialize (e.g. the program is unknown)</li>
<li>If the subprocess exits with a non-zero status code</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ command(["echo", "hello"]) }} =&gt; "hello\n"
{{ command(["grep", "1"], stdin="line 1\nline2") }} =&gt; "line 1\n"
</code></pre>
<blockquote>
<p><code>command</code> is commonly paired with <a href="api/template_functions.html#trim"><code>trim</code></a> to remove trailing
newlines from command output: <code>{{ command(["echo", "hello"]) | trim() }}</code></p>
</blockquote>
<h3 id="concat"><a class="header" href="#concat">concat</a></h3>
<pre><code class="language-typescript">concat(elements: string[]): string
</code></pre>
<p>Concatenate any number of strings together</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>elements</code>: Strings to concatenate together. Any non-string values will be
stringified</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ concat(['My name is ', name, ' and I am ', age]) }} =&gt; "My name is Ted and I am 37"
{{ file("data.json") | jsonpath("$.users[*].name") | concat() }} =&gt; Concatenate all names in the JSON together
</code></pre>
<h3 id="debug"><a class="header" href="#debug">debug</a></h3>
<pre><code class="language-typescript">debug(value: value): value
</code></pre>
<p>Print a value to stdout, returning the same value. This isn't very useful
in the TUI because stdout gets clobbered, but it can be helpful for
debugging templates with the CLI.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>value</code>: The value to print and return</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ debug("hello") }} =&gt; "hello" (also prints "hello" to stdout)
{{ file("data.json") | debug() | jsonpath("$.data") }} =&gt; Extract data field and print intermediate result
</code></pre>
<h3 id="env"><a class="header" href="#env">env</a></h3>
<pre><code class="language-typescript">env(variable: string): string
</code></pre>
<p>Get the value of an environment variable, or <code>""</code> if not set.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>variable</code>: Name of the environment variable to read</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ env("HOME") }} =&gt; "/home/username"
{{ env("NONEXISTENT") }} =&gt; null
</code></pre>
<h3 id="file"><a class="header" href="#file">file</a></h3>
<pre><code class="language-typescript">file(path: string): bytes
</code></pre>
<p>Load contents of a file. While the output type is <code>bytes</code>,
<a href="api/../user_guide/templates/values.html#bytes-vs-string">in most cases you can use it interchangeably as a
string</a>. <code>bytes</code>
support means you can also use this to load binary files such as images,
which can be useful for request bodies.</p>
<p>This function supports <a href="api/../user_guide/streaming.html">streaming</a>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>path</code>: Path to the file to read, relative to the collection file
(<code>slumber.yml</code>) in use. A leading <code>~</code> will be expanded to your home
directory (<code>$HOME</code>).</li>
</ul>
<p><strong>Errors</strong></p>
<ul>
<li>If an I/O error occurs while opening the file (e.g. file missing)</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ file("config.json") }} =&gt; Contents of config.json file
</code></pre>
<h3 id="float"><a class="header" href="#float">float</a></h3>
<pre><code class="language-typescript">float(value: value): float
</code></pre>
<p>Convert a value to a float</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>value</code>: Value to convert</li>
</ul>
<p><strong>Errors</strong></p>
<ul>
<li>If <code>value</code> is a string or byte string that doesn't parse to a float, or an
inconvertible type such as an array</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ float('3.5') }} =&gt; 3.5
{{ float(b'3.5') }} =&gt; 3.5
{{ float(3) }} =&gt; 3.0
{{ float(null) }} =&gt; 0.0
{{ float(false) }} =&gt; 0.0
{{ float(true) }} =&gt; 1.0
</code></pre>
<h3 id="integer"><a class="header" href="#integer">integer</a></h3>
<pre><code class="language-typescript">integer(value: value): integer
</code></pre>
<p>Convert a value to an int</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>value</code>: Value to convert</li>
</ul>
<p><strong>Errors</strong></p>
<ul>
<li>If <code>value</code> is a string or byte string that doesn't parse to an integer, or
an inconvertible type such as an array</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ integer('3') }} =&gt; 3
{{ integer(b'3') }} =&gt; 3
{{ integer(3.5) }} =&gt; 3
{{ integer(null) }} =&gt; 0
{{ integer(false) }} =&gt; 0
{{ integer(true) }} =&gt; 1
</code></pre>
<h3 id="jq"><a class="header" href="#jq">jq</a></h3>
<pre><code class="language-typescript">jq(
  query: string,
  value: value,
  mode?: "auto" | "single" | "array",
): value
</code></pre>
<p>Transform a JSON value using a <a href="https://jqlang.org/manual/">jq</a> query. For
simple queries, <a href="api/template_functions.html#jsonpath"><code>jsonpath</code></a> is often simpler to use, but <code>jq</code> is
much more powerful and flexible. In particular, <code>jq</code> can be used to
construct new JSON values, while JSONPath can only extract from existing
values.</p>
<p>This function is most useful when used after a data-providing function such
as <a href="api/template_functions.html#file"><code>file</code></a> or <a href="api/template_functions.html#response"><code>response</code></a>.</p>
<p>This relies on a pure Rust reimplmentation of <code>jq</code> called
<a href="https://github.com/01mf02/jaq">jaq</a>. While largely compliant with the
original <code>jq</code> behavior, <a href="https://github.com/01mf02/jaq?tab=readme-ov-file#differences-between-jq-and-jaq">there are some differences</a>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>value</code>: JSON value to query. If this is a string or bytes, it will be
parsed as JSON before being queried. If it's already a structured value
(bool, array, etc.), it will be mapped directly to JSON. This value is
typically piped in from the output of <code>response()</code> or <code>file()</code>.</li>
<li><code>query</code>: <code>jq</code> query string (see <code>jq</code> docs linked above)</li>
<li><code>mode</code> (default: <code>"auto"</code>): How to handle multiple results (see table
below)</li>
</ul>
<p>An explanation of <code>mode</code> using this object as an example:</p>
<pre><code class="language-json">[{ "name": "Apple" }, { "name": "Kiwi" }, { "name": "Mango" }]
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Description</th><th><code>$.id</code></th><th><code>$[0].name</code></th><th><code>$[*].name</code></th></tr></thead><tbody>
<tr><td><code>auto</code></td><td>If query returns a single value, use it. If it returns multiple, use a JSON array</td><td>Error</td><td><code>Apple</code></td><td><code>["Apple", "Kiwi", "Mango"]</code></td></tr>
<tr><td><code>single</code></td><td>If a query returns a single value, use it. Otherwise, error.</td><td>Error</td><td><code>Apple</code></td><td>Error</td></tr>
<tr><td><code>array</code></td><td>Return results as an array, regardless of count.</td><td><code>[]</code></td><td><code>["Apple"]</code></td><td><code>["Apple", "Kiwi", "Mango"]</code></td></tr>
</tbody></table>
</div>
<p><strong>Errors</strong></p>
<ul>
<li>If <code>value</code> is a string with invalid JSON</li>
<li>If the query returns no results and <code>mode='auto'</code> or <code>mode='single'</code></li>
<li>If the query returns 2+ results and <code>mode='single'</code></li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ response('get_user') | jq(".first_name") }} =&gt; "Alice"
</code></pre>
<h3 id="json_parse"><a class="header" href="#json_parse">json_parse</a></h3>
<pre><code class="language-typescript">json_parse(value: string): value
</code></pre>
<p>Parse a JSON string to a template value.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>value</code>: JSON string</li>
</ul>
<p><strong>Errors</strong></p>
<ul>
<li>If <code>value</code> is not valid JSON</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ json_parse('{"name": "Alice"}') }} =&gt; {"name": "Alice"}
# Commonly combined with file() or response() because they spit out raw JSON
{{ file('body.json') | json_parse() }} =&gt; {"name": "Alice"}"
{{ response('get_user') | json_parse() }} =&gt; {"name": "Alice"}"
</code></pre>
<p>This can be used in <code>json</code> request bodies to create dynamic non-string
values.</p>
<pre><code class="language-yaml">body:
type: json
data: {
"data": "{{ response('get_user') | json_parse() }}"
}
</code></pre>
<p>This will render a request body like:</p>
<pre><code class="language-json">{"data": {"name": "Alice"}}
</code></pre>
<h3 id="jsonpath"><a class="header" href="#jsonpath">jsonpath</a></h3>
<pre><code class="language-typescript">jsonpath(
  query: string,
  value: value,
  mode?: "auto" | "single" | "array",
): value
</code></pre>
<p>Transform a JSON value using a JSONPath query. See
<a href="https://datatracker.ietf.org/doc/html/rfc9535">JSONPath specification</a> or
<a href="https://jsonpath.com/">jsonpath.com</a> for query syntax. For more complex
queries, you may want to use <a href="api/template_functions.html#jq"><code>jq</code></a> instead.</p>
<p>This function is most useful when used after a data-providing function such
as <a href="api/template_functions.html#file"><code>file</code></a> or <a href="api/template_functions.html#response"><code>response</code></a>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>value</code>: JSON value to query. If this is a string or bytes, it will be
parsed as JSON before being queried. If it's already a structured value
(bool, array, etc.), it will be mapped directly to JSON. This value is
typically piped in from the output of <code>response()</code> or <code>file()</code>.</li>
<li><code>query</code>: JSONPath query string</li>
<li><code>mode</code> (default: <code>"auto"</code>): How to handle multiple results (see table
below)</li>
</ul>
<p>An explanation of <code>mode</code> using this object as an example:</p>
<pre><code class="language-json">[{ "name": "Apple" }, { "name": "Kiwi" }, { "name": "Mango" }]
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Description</th><th><code>$.id</code></th><th><code>$[0].name</code></th><th><code>$[*].name</code></th></tr></thead><tbody>
<tr><td><code>auto</code></td><td>If query returns a single value, use it. If it returns multiple, use a JSON array</td><td>Error</td><td><code>Apple</code></td><td><code>["Apple", "Kiwi", "Mango"]</code></td></tr>
<tr><td><code>single</code></td><td>If a query returns a single value, use it. Otherwise, error.</td><td>Error</td><td><code>Apple</code></td><td>Error</td></tr>
<tr><td><code>array</code></td><td>Return results as an array, regardless of count.</td><td><code>[]</code></td><td><code>["Apple"]</code></td><td><code>["Apple", "Kiwi", "Mango"]</code></td></tr>
</tbody></table>
</div>
<p><strong>Errors</strong></p>
<ul>
<li>If <code>value</code> is a string with invalid JSON</li>
<li>If the query returns no results and <code>mode='auto'</code> or <code>mode='single'</code></li>
<li>If the query returns 2+ results and <code>mode='single'</code></li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ response('get_user') | jsonpath("$.first_name") }} =&gt; "Alice"
</code></pre>
<h3 id="prompt"><a class="header" href="#prompt">prompt</a></h3>
<pre><code class="language-typescript">prompt(message?: string, default?: string, sensitive?: boolean): string
</code></pre>
<p>Prompt the user to enter a text value.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>message</code>: Optional prompt message to display to the user</li>
<li><code>default</code>: Optional default value to pre-fill the input</li>
<li><code>sensitive</code>: Mask the input while typing. Unlike the
<a href="api/template_functions.html#sensitive"><code>sensitive</code></a> function, which masks <em>output</em> values, this flag
enables masking on the input <em>and</em> output. This means it's redundant to
combine <code>sensitive</code> with <code>prompt</code>.</li>
</ul>
<p><strong>Errors</strong></p>
<ul>
<li>If the user doesn't give a response</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh"># Prompt with no message. User may be confused!
{{ prompt() }} =&gt; "What do I put here? Help!!"
# Prompts with custom message
{{ prompt(message="Enter your name") }} =&gt; "Barry Barracuda"
# Mask input while the user types
{{ prompt(message="Password", sensitive=true) }} =&gt; "hunter2"
</code></pre>
<h3 id="response"><a class="header" href="#response">response</a></h3>
<pre><code class="language-typescript">response(
  recipe_id: string,
  trigger?: "never" | "no_history" | "always" | Duration,
): bytes
</code></pre>
<p>Load the most recent response body for the given recipe and current profile.
While the output type is <code>bytes</code>, <a href="api/../user_guide/templates/values.html#bytes-vs-string">in most cases you can use it
interchangeably as a
string</a>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>recipe_id</code>: ID (<strong>not</strong> name) of the recipe to load the response from</li>
<li><code>trigger</code>: When to execute the upstream request</li>
</ul>
<p>An explanation of <code>trigger</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>"never"</code></td><td>Never trigger. The most recent response in history for the upstream recipe will always be used; error if there is none</td></tr>
<tr><td><code>"no_history"</code></td><td>Trigger only if there is no response in history for the upstream recipe</td></tr>
<tr><td><code>"always"</code></td><td>Always execute the upstream request</td></tr>
<tr><td><code>Duration</code></td><td>Trigger if the most recent response for the upstream recipe is older than some duration, or there is none</td></tr>
</tbody></table>
</div>
<p><code>Duration</code> is a <code>string</code> in the format <code>&lt;quantity&gt;&lt;unit&gt;...</code>, e.g. <code>"3h"</code>.
Supported units are:</p>
<ul>
<li><code>s</code> (seconds)</li>
<li><code>m</code> (minutes)</li>
<li><code>h</code> (hours)</li>
<li><code>d</code> (days)</li>
</ul>
<p>Multiple units can be combined:</p>
<ul>
<li><code>"10h5m"</code>: 10 hours and 5 minutes</li>
<li><code>"3d2s"</code>: 3 days and 2 seconds</li>
</ul>
<p><strong>Errors</strong></p>
<ul>
<li>If <code>recipe</code> isn't in the collection</li>
<li>If there is no request in history and <code>trigger='never'</code></li>
<li>If a request is triggered and failed</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh"># Use the most recent response body. Error if there are no responses in history
{{ response("login") }} =&gt; {"token": "abc123"}
# Re-execute if older than 1 hour
{{ response("login", trigger="1h") }} =&gt; {"token": "abc123"}
# Combine with jsonpath for data extraction
{{ response("login") | jsonpath("$.token") }} =&gt; "abc123"
</code></pre>
<blockquote>
<p><code>response</code> is commonly combined with <a href="api/template_functions.html#jsonpath"><code>jsonpath</code></a> to extract
data from JSON responses</p>
</blockquote>
<h3 id="response_header"><a class="header" href="#response_header">response_header</a></h3>
<pre><code class="language-typescript">response_header(
  recipe_id: string,
  header: string,
  trigger?: "never" | "no_history" | "always" | Duration,
): bytes
</code></pre>
<p>Load a header value from the most recent response for a recipe and the
current profile. While the output type is <code>bytes</code>,
<a href="api/../user_guide/templates/values.html#bytes-vs-string">in most cases you can use it interchangeably as a
string</a>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>recipe_id</code>: ID (<strong>not</strong> name) of the recipe to load the response from</li>
<li><code>header</code>: Name of the header to extract (case-insensitive)</li>
<li><code>trigger</code>: When to execute the upstream request vs using the cached
response; <a href="api/template_functions.html#response">see <code>response</code></a></li>
</ul>
<p><strong>Errors</strong></p>
<ul>
<li>If <code>recipe</code> isn't in the collection</li>
<li>If there is no request in history and <code>trigger='never'</code></li>
<li>If a request is triggered and failed</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh"># Fetch current rate limit, refreshed if older than 5 minutes
{{ response_header("get_rate_limit", "X-Rate-Limit", trigger="5m") }} =&gt; Value of X-Rate-Limit response header
</code></pre>
<h3 id="select"><a class="header" href="#select">select</a></h3>
<pre><code class="language-typescript">select(
  options: (string | { "label": string, "value": value })[],
  message?: string,
): value
</code></pre>
<p>Ask the user to select a value from a list.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>options</code>: List of options to choose from. Each option can be either a
string <em>or</em> an object with the fields <code>"label"</code> and <code>"value"</code>. If an
object is given, the <code>"label"</code> field will be shown to the user, but the
corresponding <code>"value"</code> field will be returned.</li>
<li><code>message</code>: Descriptive message to display to the user</li>
</ul>
<p><strong>Errors</strong></p>
<ul>
<li>If <code>options</code> is empty</li>
<li>If the user doesn't give a response</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ select(["dev", "staging", "prod"]) }} =&gt; "dev"
# Custom prompt message
{{ select(["GET", "POST", "PUT"], message="HTTP method") }} =&gt; "POST"
# "label" will be shown to the user, but the corresponding "value" will be returned
{{ select([{"label": "Sam", "value": 1}, {"label": "Mike", "value": 2}]) }} =&gt; 2
# jq() can be used to construct labelled options dynamically
{{ [{"name": "Sam", "id": 1}, {"name": "Mike", "id": 2}]
| jq('[.[] | {label: .name, value: .id}]')
| select(message="Select user") }}
</code></pre>
<h3 id="sensitive"><a class="header" href="#sensitive">sensitive</a></h3>
<pre><code class="language-typescript">sensitive(value: string): string
</code></pre>
<p>Mark a value as sensitive, masking it in template previews. This has no
impact on how requests are actually sent, it only prevents sensitive values
such as passwords from being displayed in the recipe preview.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>value</code>: String to mask</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ sensitive("hunter2") }} =&gt; "•••••••" (in preview)
</code></pre>
<h3 id="string"><a class="header" href="#string">string</a></h3>
<pre><code class="language-typescript">string(value: value): string
</code></pre>
<p>Stringify a value. Any value can be converted to a string except for
non-UTF-8 bytes</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>value</code>: Value to stringify</li>
</ul>
<p><strong>Errors</strong></p>
<ul>
<li>If <code>value</code> is a byte string that isn't valid UTF-8</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ string('hello') }} =&gt; "hello"
{{ string(b'hello') }} =&gt; "hello"
{{ string([1, 2, 3]) }} =&gt; "[1, 2, 3]"
</code></pre>
<h3 id="trim"><a class="header" href="#trim">trim</a></h3>
<pre><code class="language-typescript">trim(value: string, mode?: "start" | "end" | "both"): string
</code></pre>
<p>Trim whitespace from the beginning and/or end of a string.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>value</code>: String to trim (typically piped in from a previous function with
<code>|</code>)</li>
<li><code>mode</code> (default: <code>"both"</code>): Section of the string to trim</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">{{ trim("  hello  ") }} =&gt; "hello"
{{ trim("  hello  ", mode="start") }} =&gt; "hello  "
# Remove trailing newline from command output
{{ command(["echo", "hello"]) | trim() }} =&gt; "hello"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<p>Slumber provides a native <a href="https://pypi.org/project/slumber-python/">Python package</a> to load and use your Slumber collections. This makes it very easy to write Python scripts that make requests based on your collection.</p>
<p>To install:</p>
<pre><code class="language-sh">pip install slumber-python
</code></pre>
<h2 id="examples-8"><a class="header" href="#examples-8">Examples</a></h2>
<h3 id="sending-a-request"><a class="header" href="#sending-a-request">Sending a Request</a></h3>
<p>By default, the library loads the same collection file that the CLI/TUI would, <a href="integration/../api/request_collection/index.html#format--loading">according to these rules</a>.</p>
<pre><code class="language-py">from slumber import Collection

collection = Collection()
response = collection.request("example_get")
print(response.context) # Response body as bytes
print(response.text) # Response body as a str
</code></pre>
<h3 id="load-different-collection"><a class="header" href="#load-different-collection">Load Different Collection</a></h3>
<p>You can specify which collection file should be loaded:</p>
<pre><code class="language-py">from slumber import Collection

# You can specify a specific file:
collection = Collection(path="./other-collection.yml")
# Or a directory, in which case the auto-load rules will apply in that dir
collection = Collection(path="./my-collections/")
</code></pre>
<h3 id="json-1"><a class="header" href="#json-1">JSON</a></h3>
<pre><code class="language-py">import json
from slumber import Collection

collection = Collection()
response = collection.request("example_get")
data = json.loads(response.text)
</code></pre>
<h3 id="check-status-code"><a class="header" href="#check-status-code">Check Status Code</a></h3>
<p>By default, Slumber will <em>not</em> raise an error for 4xx/5xx status codes, only if the request/response fails to transmit. To check the status code, use <code>raise_for_status()</code>:</p>
<pre><code class="language-py">from slumber import Collection

collection = Collection()
response = collection.request("example_get")
response.raise_for_status()
</code></pre>
<h3 id="override-profile-fields"><a class="header" href="#override-profile-fields">Override Profile Fields</a></h3>
<p>If you want to override individual profile fields in your script, you can use the <code>overrides=</code> kwarg to <code>request()</code>. For example, if you want to hardcode the <code>host</code> field instead of using the one from your profile:</p>
<pre><code class="language-py">from slumber import Collection

collection = Collection()
response = collection.request(
    "example_get",
    overrides={"host": "http://localhost:3000"},
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="neovim-integration"><a class="header" href="#neovim-integration">Neovim Integration</a></h1>
<p>Slumber can be integrated into Neovim to allow you quickly switch between your codebase and Slumber.</p>
<p>Ensure you have <code>which-key</code> and <code>toggleterm</code> installed. Most premade distros (LunarVim, etc) will have these installed by default.</p>
<p>Add this snippet to your Neovim config:</p>
<pre><code class="language-lua">local Slumber = {}
Slumber.toggle = function()
    local Terminal = require("toggleterm.terminal").Terminal
    local slumber = Terminal:new {
        cmd = "slumber",
        hidden = true,
        direction = "float",
        float_opts = {
            border = "none",
            width = 100000,
            height = 100000,
        },
        on_open = function(_)
            vim.cmd "startinsert!"
        end,
        on_close = function(_) end,
        count = 99,
    }
    slumber:toggle()
end

local wk = require("which-key")
wk.add({
    -- Map space V S to open slumber 
    { "&lt;leader&gt;vs", Slumber.toggle, desc = "Open in Slumber"}
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logs"><a class="header" href="#logs">Logs</a></h1>
<p>Each Slumber session logs information and events to a log file. This can often be helpful in debugging bugs and other issues with the app. All sessions of Slumber log to the same file. Currently there is no easy to way disambiguate between logs from parallel sessions :(</p>
<h2 id="finding-the-log-file"><a class="header" href="#finding-the-log-file">Finding the Log File</a></h2>
<p>To find the path to the log file, hit the <code>?</code> to open the help dialog. It will be listed under the General section. Alternatively, run the command <code>slumber show paths log</code>.</p>
<p>Once you have the path to a log file, you can watch the logs with <code>tail -f &lt;log file&gt;</code>, or get the entire log contents with <code>cat &lt;log file&gt;</code>.</p>
<h2 id="increasing-verbosity"><a class="header" href="#increasing-verbosity">Increasing Verbosity</a></h2>
<p>In some scenarios, the default logging level is not verbose enough to debug issues. To increase the verbosity, set the <code>RUST_LOG</code> environment variable when starting Slumber:</p>
<pre><code class="language-sh">RUST_LOG=slumber=&lt;level&gt; slumber ...
</code></pre>
<p>The <code>slumber=</code> filter applies this level only to Slumber's internal logging, instead of all libraries, to cut down on verbosity that will likely not be helpful. The available log levels are, in increasing verbosity:</p>
<ul>
<li><code>error</code></li>
<li><code>warn</code></li>
<li><code>info</code></li>
<li><code>debug</code></li>
<li><code>trace</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lost-request-history"><a class="header" href="#lost-request-history">Lost Request History</a></h1>
<p>If you've lost your request history, there are a few possible causes. In most cases request history is non-essential, but if you really want it back there may be a fix available.</p>
<p>If none of these fixes worked for you, and you still want your request history back, please <a href="https://github.com/LucasPickering/slumber/issues/new">open an issue</a> and provide as much detail as possible.</p>
<h2 id="moved-collection-file"><a class="header" href="#moved-collection-file">Moved Collection File</a></h2>
<p>If history is lost for an entire collection, the most likely cause is that you moved your collection file. To fix this, you can <a href="troubleshooting/../user_guide/database.html#migrating-collections">migrate your request history</a>.</p>
<h2 id="changed-recipe-id"><a class="header" href="#changed-recipe-id">Changed Recipe ID</a></h2>
<p>If you've lost request history for just a single recipe, you likely changed the recipe ID, which is the key associated with the recipe in your collection file (the parent folder(s) do <strong>not</strong> affect this). Unfortunately currently the only way to fix this is to revert to the old recipe ID.</p>
<h2 id="wrong-profile-or-changed-profile-id"><a class="header" href="#wrong-profile-or-changed-profile-id">Wrong Profile or Changed Profile ID</a></h2>
<p>Each request+response in history is associated with a specific profile. If you're not seeing your expected request history, you may have a different profile selected than the one used to send the request(s).</p>
<p>Alternatively, you may have changed the ID of the associated profile. If so, unfortunately the only way to fix this is to revert to the old profile ID.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tls-certificate-errors"><a class="header" href="#tls-certificate-errors">TLS Certificate Errors</a></h1>
<p>If you're receiving certificate errors such as this one:</p>
<pre><code>invalid peer certificate: UnknownIssuer
</code></pre>
<p>This is probably because the TLS certificate of the server you're hitting is expired, invalid, or self-signed. The best solution is to fix the error on the server, either by renewing the certificate or creating a signed one. In most cases this is the best solution. If not possible, you should just disable TLS on your server because it's not doing anything for you anyway.</p>
<p>If you can't or don't want to fix the certificate, and you need to keep TLS enabled for some reason, it's possible to configure Slumber to ignore TLS certificate errors on certain hosts.</p>
<blockquote>
<p><strong>WARNING:</strong> This is dangerous. You will be susceptible to MITM attacks on these hosts. Only do this if you control the server you're hitting, and are confident your network is not compromised.</p>
</blockquote>
<ul>
<li>Open your <a href="troubleshooting/../api/configuration/index.html">Slumber configuration</a></li>
<li>Add the field <code>ignore_certificate_hosts: ["&lt;hostname&gt;"]</code>
<ul>
<li><code>&lt;hostname&gt;</code> is the domain or IP of the server you're requesting from</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v3-to-v4-migration"><a class="header" href="#v3-to-v4-migration">v3 to v4 Migration</a></h1>
<p>Slumber 4.0 introduced a <a href="https://github.com/LucasPickering/slumber/releases/tag/v4.0.0">set of breaking changes</a> to the collection format, requiring migration of your collection files to the new format. You have two options to migrate automatically:</p>
<p><strong>CLI Migration Tool</strong></p>
<p>You can upgrade with the migration tool included in the v4 CLI:</p>
<pre><code class="language-sh">slumber import v3 &lt;old file&gt; &lt;new file&gt;
</code></pre>
<p>The generated collection will be <em>functionally</em> equivalent to the old collection, but due to limitations in the Rust YAML ecosystem, non-semantic content such as whitespace, comments, and anchors/aliases will be lost. Depending on the complexity of your collection, this migration may be 100% of what you need, or it may provide a good starting point for you to finish cleaning up by hand. You can also use an LLM to do the touch-ups, but in that case it may just be easier to do the entire migration via LLM (see next section).</p>
<blockquote>
<p>"Functionally equivalent" means loading the TUI on the new collection should show you the exact same set of profiles/requests that you saw in v3. If this isn't the case (e.g. if a new template doesn't function the same as it did before), please <a href="https://github.com/lucaspickering/slumber/issues/new">file a bug</a>!</p>
</blockquote>
<p><strong>LLM Migration</strong></p>
<p>If you're open to using an LLM, you can provide it this guide and it should generate a v4 collection that is functionally equivalent, retain comments and deduplicate content via <code>$ref</code>. Provide it this prompt:</p>
<pre><code>Migrate this file from Slumber v3 to Slumber v4 using this guide:
https://slumber.lucaspickering.me/book/other/v4_migration.html
</code></pre>
<blockquote>
<p>Some AI Agents won't follow URLs or only fetch snippets of the page rather than the entire content. If your new collection doesn't work, try copying the entire page content below into the prompt.</p>
</blockquote>
<h2 id="manual-migration"><a class="header" href="#manual-migration">Manual Migration</a></h2>
<p>If you prefer to do the import manually, or if the automatic importer isn't working for you, here's what needs to be changed:</p>
<h3 id="rewrite-templates"><a class="header" href="#rewrite-templates">Rewrite Templates</a></h3>
<p>Rewrite templates to use the new function-based syntax:</p>
<ul>
<li>Replace each chain type with its <a href="other/../api/template_functions.html">equivalent function call</a></li>
<li>For chains used multiple times, deduplicate the migrated template expression using <a href="other/../user_guide/templates/examples.html#deduplicating-template-expressions">common profile fields</a></li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="language-yaml"># v3
chains:
  file:
    source: !file
      path: "./data.txt"
    trim: both
  response:
    source: !request
      recipe: login
      selector: $.token

requests: !request
  r1:
    query:
      file: "{{chains.file}}"
      response: "{{chains.response}}"

# v4
requests:
  r1:
    query:
      file: "{{ file('./data.txt') | trim() }}"
      response: "{{ response('login') | jsonpath('$.token') }}"
</code></pre>
<p>The v3 chain sources (and their parameters) have each been replaced by a corresponding function.</p>
<blockquote>
<p>In the new template language, required arguments are passed as positional arguments <code>file("my/path")</code> while optional arguments are passed as keywords <code>prompt(default="Default")</code>. These examples include all optional arguments for completeness, but they can be omitted if not needed.</p>
</blockquote>
<p><strong><code>!command</code> becomes <a href="other/../api/template_functions.html#command"><code>command</code></a></strong></p>
<pre><code class="language-yaml">source: !command
  command: ["echo", "test"]
  stdin: "{{host}}"
# becomes
"{{ command(['echo', 'test'], stdin=host) }}"
</code></pre>
<blockquote>
<p>Previously, an error was not triggered if the command failed with a non-zero status code. This will now trigger an error. If you want the template to render even if the command fails, you can use something like `['sh', '-c', ]</p>
</blockquote>
<p><strong><code>!env</code> becomes <a href="other/../api/template_functions.html#env"><code>env</code></a></strong></p>
<pre><code class="language-yaml">source: !env
  variable: MY_VAR
# becomes
"{{ env('MY_VAR') }}"
</code></pre>
<p><strong><code>!file</code> becomes <a href="other/../api/template_functions.html#file"><code>file</code></a></strong></p>
<pre><code class="language-yaml">source: !file
  path: my/file
# becomes
"{{ file('my/file') }}"
</code></pre>
<p><strong><code>!prompt</code> becomes <a href="other/../api/template_functions.html#prompt"><code>prompt</code></a></strong></p>
<pre><code class="language-yaml">source: !prompt
  message: "Enter data"
  default: "Default"
sensitive: true
# becomes
"{{ prompt(message='Enter data', default='Default', sensitive=true) }}"
</code></pre>
<p><strong><code>!request</code> split into <a href="other/../api/template_functions.html#response"><code>response</code></a> and <a href="other/../api/template_functions.html#response_header"><code>response_header</code></a></strong></p>
<pre><code class="language-yaml">source: !request
  recipe: "login"
  trigger: !expire 12h
  section: !body
# becomes
"{{ response('login', trigger='12h') }}"
</code></pre>
<pre><code class="language-yaml">source: !request
  recipe: "login"
  trigger: !expire 12h
  section: !header Content-Type
# becomes
"{{ response_header('login', 'Content-Type', trigger='12h') }}"
</code></pre>
<p><strong><code>!select</code> becomes <a href="other/../api/template_functions.html#select"><code>select</code></a></strong></p>
<pre><code class="language-yaml">source: !select
  options:
    - option1
    - option2
  message: "Message"
# becomes
"{{ select(options=['option1', 'option2'], message='Message') }}"
</code></pre>
<p>In addition, the following chain fields have been replaced by utility functions:</p>
<ul>
<li><code>selector</code> and <code>selector_mode</code> -&gt; <a href="other/../api/template_functions.html#jsonpath"><code>jsonpath</code></a></li>
<li><code>sensitive</code> -&gt; <a href="other/../api/template_functions.html#sensitive"><code>sensitive</code></a></li>
<li><code>trim</code> -&gt; <a href="other/../api/template_functions.html#trim"><code>trim</code></a></li>
<li><code>content_type</code> is no longer needed, as only JSON was ever supported</li>
</ul>
<p>These functions can be used via the pipe operator:</p>
<pre><code class="language-yaml">source: !file
  path: "file.json"
trim: both
selector: "$.items"
selector_mode: array
sensitive: true
# becomes
"{{ file('file.json') | trim(mode='both') | jsonpath('$.items', mode='array') | sensitive() }}"
</code></pre>
<p>Finally, there is a function <code>concat()</code> that can be used to replicate the behavior of nested templates within chain config:</p>
<pre><code class="language-yaml">chains:
  file_name:
    source: !prompt
      message: File name
  path:
    source: !file
      path: "data/{{file_name}}.json"
# becomes
"{{ file(concat(['data/', prompt(message='File name'), '.json']))"
</code></pre>
<blockquote>
<p><code>concat()</code> takes a single array argument!</p>
</blockquote>
<p>This is only necessary if you have nested templates <strong>with multiple components</strong>. In other words, if you do this conversion but the array passed to <code>concat()</code> only has one element, you can just omit the <code>concat()</code>.</p>
<h3 id="replace-anchors-with-ref"><a class="header" href="#replace-anchors-with-ref">Replace Anchors with <code>$ref</code></a></h3>
<p>The previous YAML anchor/alias and spread syntax has been replaced by a more powerful <code>$ref</code> syntax, akin to <a href="https://swagger.io/docs/specification/v3_0/using-ref/">OpenAPI</a>.</p>
<pre><code class="language-yaml"># v3
.base_request: &amp;base_request
  method: GET
  headers:
    Accept: application/json

requests:
  r1: !request
    &lt;&lt;: *base_request
    url: "https://myfishes.fish/fishes"

# v4
.base_request:
  method: GET
  headers:
    Accept: application/json

requests:
  r1:
    $ref: "#/.base_request"
    url: "https://myfishes.fish/fishes"
</code></pre>
<blockquote>
<p>Same as <code>&lt;&lt;:</code>, <code>$ref</code> does <em>not</em> do a deep merge of objects. In the above example, any recipe containing a <code>headers</code> field would entirely overwrite <code>.base_request/headers</code></p>
</blockquote>
<p>See <a href="other/../user_guide/composition.html">Collection Reuse &amp; Composition</a> to learn more about the power of <code>$ref</code>, including sharing collection components across files.</p>
<h3 id="remove-tag-syntax"><a class="header" href="#remove-tag-syntax">Remove <code>!tag</code> Syntax</a></h3>
<p>Slumber no longer uses YAML <code>!tag</code> syntax.</p>
<ul>
<li>Remove <code>!request</code> and <code>!folder</code> entirely (they're now detected automatically)</li>
<li>Authentication: <code>!basic</code> and <code>!bearer</code> have been replaced by <code>authentication.type</code>:</li>
</ul>
<pre><code class="language-yaml"># v3
authentication: !basic
  username: user1
  password: hunter2
authentication: !bearer token123

# v4
authentication:
  type: basic
  username: user1
  password: hunter2
authentication:
  type: bearer
  token: token123
</code></pre>
<ul>
<li>Body: <code>!json</code>, <code>!form_urlencoded</code>, and <code>!form_multipart</code> have been replaced by <code>type</code> and <code>data</code> fields:</li>
</ul>
<pre><code class="language-yaml"># v3
body: !json
  key: value
body: !form_urlencoded
  field1: value
body: !form_multipart
  field1: value

# v4
body:
  type: json
  data:
    key: value
body:
  type: form_urlencoded
  data:
    field1: value
body:
  type: form_multipart
  data:
    field1: value
</code></pre>
<h3 id="query-parameters-2"><a class="header" href="#query-parameters-2">Query Parameters</a></h3>
<p>Previously, query parameters could be expressed as either a mapping of <code>param: value</code> OR a sequence of strings <code>"param=value"</code>. This enabled the use of multiple instances of the same parameter. Query parameters must be mappings now, but support both a singular OR sequence value to enable multiple values for the same parameter.</p>
<p><strong>Any <code>query</code> blocks already in the <code>param: value</code> format do not need to be changed</strong>.</p>
<p>For any <code>query</code> blocks in the <code>"param=value"</code> format, update them like so:</p>
<pre><code class="language-yaml"># v3
query:
  - param1=value1
  - param1=value2
  - param2=value7

# v4
query:
  param1: [value1, value2]
  param2: value7
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>You can also browse release history via the <a href="https://github.com/LucasPickering/slumber/releases">GitHub Releases page</a>.</p>
<!-- Changelog uses an anchor to identify its content -->
<h2 id="420---2025-10-14"><a class="header" href="#420---2025-10-14">[4.2.0] - 2025-10-14</a></h2>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<ul>
<li>Add <a href="https://slumber.lucaspickering.me/integration/python.html">Python bindings</a>, allowing you to use your Slumber collection from Python scripts without having to invoke the CLI</li>
<li>Add <a href="https://slumber.lucaspickering.me/api/template_functions.html#jq"><code>jq</code></a> function to the template language, to query and transform JSON with <a href="https://jqlang.org/manual/">jq</a></li>
<li><code>select()</code> now accepts a list of objects <code>{"label": "Label", "value": "Value"}</code> in addition to a list of strings <a href="https://github.com/LucasPickering/slumber/issues/609">#609</a>
<ul>
<li>This allows you to pass a list of values where the returned value is different from the string you see in the select list.</li>
<li>For example, to select a user from a list where you select users by name but the returned value is their ID: <code>select([{"label": "User 1", "value": 1}, {"label": "User 2", "value": 2}])</code></li>
<li><a href="https://slumber.lucaspickering.me/api/template_functions.html#select">See docs for more</a></li>
</ul>
</li>
<li>Add URL tab to the recipe pane, allowing the URL to be temporarily overridden</li>
</ul>
<h3 id="changed"><a class="header" href="#changed">Changed</a></h3>
<ul>
<li><code>Edit Collection</code> TUI has been replaced by <code>Edit Recipe</code>, which opens the file to the selected recipe
<ul>
<li>This will make it much easier to make tweaks to a recipe</li>
</ul>
</li>
<li>The <code>Body</code> and <code>Authentication</code> tabs of the <code>Recipe</code> pane are now disabled if the recipe doesn't have a body/authentication (respectively)</li>
<li>Disabled actions can no longer be selected in the action menu</li>
<li><code>slumber show config --edit</code> and <code>slumber show collection --edit</code> now display the error if the file is invalid after editing</li>
</ul>
<h2 id="410---2025-09-30"><a class="header" href="#410---2025-09-30">[4.1.0] - 2025-09-30</a></h2>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<ul>
<li>Add support for streaming large HTTP bodies with the new <code>stream</code> body type <a href="https://github.com/LucasPickering/slumber/issues/256">#256</a>
<ul>
<li><a href="https://slumber.lucaspickering.me/user_guide/streaming.html">See docs</a></li>
</ul>
</li>
</ul>
<h3 id="changed-1"><a class="header" href="#changed-1">Changed</a></h3>
<ul>
<li><code>form_multipart</code> fields that consist of a single call to <code>file()</code> will now include the correct <code>Content-Type</code> header and <code>filename</code> field of the <code>Content-Disposition</code> header <a href="https://github.com/LucasPickering/slumber/issues/582">#582</a>
<ul>
<li><a href="https://slumber.lucaspickering.me/user_guide/streaming.html">See docs</a></li>
</ul>
</li>
<li>Previews of <code>prompt()</code> will now show the default value if possible</li>
<li>Recipe ID is now shown in the top-right of the Recipe pane header</li>
</ul>
<h3 id="fixed"><a class="header" href="#fixed">Fixed</a></h3>
<ul>
<li>Fix <code>slumber generate curl</code> output for multipart forms with file fields</li>
<li><code>slumber import insomnia</code> now imports some dynamic expressions. Values chained from other responses now properly import as <code>response()</code>/<code>response_header()</code> calls <a href="https://github.com/LucasPickering/slumber/issues/164">#164</a></li>
<li>Improve TUI performance when handling lots of input events</li>
</ul>
<h2 id="401---2025-09-14"><a class="header" href="#401---2025-09-14">[4.0.1] - 2025-09-14</a></h2>
<h3 id="fixed-1"><a class="header" href="#fixed-1">Fixed</a></h3>
<ul>
<li>Remove <code>output</code> argument for <code>command()</code>
<ul>
<li>This wasn't intended to be released and didn't actually work</li>
</ul>
</li>
</ul>
<h2 id="400---2025-09-12"><a class="header" href="#400---2025-09-12">[4.0.0] - 2025-09-12</a></h2>
<p><a href="https://slumber.lucaspickering.me/other/v4_migration.html">Migration guide</a></p>
<h3 id="highlights"><a class="header" href="#highlights">Highlights</a></h3>
<p>4.0 is Slumber's largest release to date, with a number of exciting improvements to the collection format. The overall goal of this release is to make collection files:</p>
<ul>
<li>Easier to read</li>
<li>Easier to write</li>
<li>Easier to share</li>
</ul>
<p>This required a number of breaking changes. For upgrade instructions, see the <code>Breaking</code> section.</p>
<h4 id="goodbye-chains-we-wont-miss-you"><a class="header" href="#goodbye-chains-we-wont-miss-you">Goodbye chains, we won't miss you</a></h4>
<p>Previously, templates could source dynamic data (such as data from other responses, files, commands, etc.) via <em>chains</em>. While powerful, they were annoying to use because you had to define your chain in one part of the collection file, then use it in another. This led to a lot of jumping around, which was especially annoying for a simple chain that only got used once. Additionally, chains were clunky and unintuitive to compose together. You could combine multiple chains together (hence the name), but it wasn't obvious how.</p>
<p>4.0 eliminates chains entirely, replacing them with functions directly in your templates, inspired by <a href="https://jinja.palletsprojects.com/en/stable/">Jinja</a> (but dramatically simplified). Here's a side-by-side comparison:</p>
<p><strong>Before</strong></p>
<pre><code class="language-yaml">chains:
  fish_ids:
    source: !request
      recipe: list_fish
      trigger: !expire 1d
    selector: $[0].id
    selector_mode: array
  fish_id:
    source: !select
      options: "{{fish_ids}}"

requests:
  list_fish:
    method: GET
    url: "{{host}}/fishes"
  get_fish:
    method: GET
    url: "{{host}}/fishes/{{fish_id}}"
</code></pre>
<p><strong>After</strong></p>
<pre><code class="language-yaml">requests:
  list_fish:
    method: GET
    url: "{{ host }}/fishes"
  get_fish:
    method: GET
    url: "{{ host }}/fishes/{{ response('fish_list', trigger='1d') | jsonpath('$[*].id', mode='array') | select() }}"
</code></pre>
<p>So much easier to follow!</p>
<p><a href="https://slumber.lucaspickering.me/user_guide/templates/functions.html">See docs for more</a>.</p>
<h4 id="share-configuration-between-collection-files-with-ref"><a class="header" href="#share-configuration-between-collection-files-with-ref">Share configuration between collection files with <code>$ref</code></a></h4>
<p>YAML merge syntax (<code>&lt;&lt;: *alias</code>) is no longer supported. Instead, the more flexible JSON reference (<code>$ref</code>) format is supported. This allows you to reuse any portion of the current collection <em>without having to declare it as an alias</em>. Even better though, <strong>you can import components from other files:</strong></p>
<pre><code class="language-yaml"># slumber.yml
requests:
  login:
    $ref: "./common.yml#/requests/login"
</code></pre>
<p><a href="https://slumber.lucaspickering.me/user_guide/composition.html">See docs for more</a>.</p>
<h4 id="json-schema"><a class="header" href="#json-schema">JSON Schema</a></h4>
<p>Slumber now exports a <a href="https://jsonschema.com">JSON Schema</a> for both its global config and request collection formats. This makes it possible to get validation and completion in your IDE. To make this possible we've ditched the YAML <code>!tag</code> syntax in favor of <code>type</code> fields within each block.</p>
<p><a href="https://slumber.lucaspickering.me/user_guide/json_schema.md">See docs for more</a>.</p>
<p><a href="https://github.com/LucasPickering/slumber/issues/374">Thanks to @anussell5559 for this suggestion</a>.</p>
<h3 id="breaking"><a class="header" href="#breaking">Breaking</a></h3>
<p>This release contains a number of breaking changes to the collection format. The major one is a change in the template format, but there are a few other quality of life improvements as well.</p>
<p>You can automatically migrate your collection to the new v4 format with:</p>
<pre><code class="language-sh">slumber import v3 &lt;old file&gt; &lt;new file&gt;
</code></pre>
<p>The new collection <em>should</em> be equivalent to the old one, but you should keep your old version around just in case something broke. If you notice any differences, please <a href="https://github.com/LucasPickering/slumber/issues/new">file a bug!</a>.</p>
<p><a href="https://slumber.lucaspickering.me/other/v4_migration.html"><strong>See the migration guide for more details</strong></a></p>
<ul>
<li>Replace template chains with a more intuitive function syntax
<ul>
<li>Instead of defining chains separately then referencing them in templates, you can now call functions directly in templates: <code>{{ response('login') | jsonpath('$.token') }}</code></li>
<li><a href="https://slumber.lucaspickering.me/user_guide/templates/functions.html">See docs for more</a></li>
</ul>
</li>
<li>Remove YAML <code>!tags</code> in favor of an inner <code>type</code> field
<ul>
<li>This change makes the format compatible with JSON Schema</li>
<li>Impacts these collection nodes:
<ul>
<li>Authentication</li>
<li>Body</li>
<li>Folder/request nodes (<code>type</code> field not required at all; node type is inferred from the object structure)</li>
</ul>
</li>
</ul>
</li>
<li>Represent query parameters as a map of <code>{parameter: value}</code> instead of a list of strings like <code>parameter=value</code>
<ul>
<li>The map format has been supported as well, but did not allow for multiple values for the same value, hence the need for the string format</li>
<li>To define multiple values for the same value, you can now use a list associated to the parameter: <code>{parameter: [value1, value2]}</code></li>
<li><a href="https://slumber.lucaspickering.me/api/request_collection/query_parameters.html">See docs</a> for examples of the new format</li>
</ul>
</li>
<li>YAML anchor/alias/merge syntax has been replaced with <code>$ref</code> references, similar to OpenAPI <a href="https://github.com/LucasPickering/slumber/issues/290">#290</a>
<ul>
<li>These references are much more flexible, including the ability to import from other files</li>
<li><a href="https://slumber.lucaspickering.me/user_guide/composition.html">See docs</a> for examples</li>
</ul>
</li>
<li>Commands in templates (previously <code>!command</code>, now <code>command()</code>) now fail if the command exits with a non-zero status code</li>
<li>Templates in a JSON body with a single dynamic chunk (such as <code>{{ username }}</code>) will now be unpacked into their inner value rather than always being stringified
<ul>
<li>This means you can now create dynamic non-string values within a JSON body</li>
<li><a href="https://slumber.lucaspickering.me/user_guide/recipes.html#body">See docs</a> for more</li>
</ul>
</li>
</ul>
<h2 id="added-2"><a class="header" href="#added-2">Added</a></h2>
<ul>
<li>Generate JSON Schema for both the collection and config formats <a href="https://github.com/LucasPickering/slumber/issues/374">#374</a>
<ul>
<li>This enables better validation and completion in your IDE; <a href="https://slumber.lucaspickering.me/user_guide/json_schema.md">see docs for more</a></li>
</ul>
</li>
</ul>
<h2 id="340---2025-08-17"><a class="header" href="#340---2025-08-17">[3.4.0] - 2025-08-17</a></h2>
<p>This release focuses on improving collection history management. The <code>slumber collections</code> subcommand is fairly niche, but is now a bit more powerful and user friendly.</p>
<h3 id="added-3"><a class="header" href="#added-3">Added</a></h3>
<ul>
<li>Add <code>slumber collections delete</code> subcommand to remove collections from history</li>
<li>Add <code>slumber history rm</code> as an alias for <code>slumber history delete</code></li>
<li>Add filter box to collection select dialog. Less scrolling, more typing!</li>
</ul>
<h3 id="changed-2"><a class="header" href="#changed-2">Changed</a></h3>
<ul>
<li><code>slumber collections migrate</code> now accepts collection IDs in addition to paths</li>
<li><code>slumber collections list</code> now includes an ID column in its output</li>
</ul>
<h3 id="fixed-2"><a class="header" href="#fixed-2">Fixed</a></h3>
<ul>
<li>Shell completion for the global <code>--file</code>/<code>-f</code> flag will now only <code>.yml</code>/<code>.yaml</code> files</li>
<li><code>slumber collections migrate</code> now accepts paths for files that don't exist on disk (as long as they existed as collections at some point)</li>
</ul>
<h2 id="330---2025-07-23"><a class="header" href="#330---2025-07-23">[3.3.0] - 2025-07-23</a></h2>
<h3 id="added-4"><a class="header" href="#added-4">Added</a></h3>
<ul>
<li>Add collection switcher modal <a href="https://github.com/LucasPickering/slumber/issues/536">#536</a>
<ul>
<li>You can now switch between any collection that you've opened in the past without having to close Slumber</li>
</ul>
</li>
<li>Add optional root-level <code>name</code> field to collections
<ul>
<li>This allows you to provide a descriptive name for the collection to show in the new switcher modal</li>
<li>The name is purely descriptive and does not need to be unique</li>
</ul>
</li>
</ul>
<h3 id="changed-3"><a class="header" href="#changed-3">Changed</a></h3>
<ul>
<li>Update to Rust 1.88</li>
</ul>
<h3 id="fixed-3"><a class="header" href="#fixed-3">Fixed</a></h3>
<ul>
<li>Fix empty actions modal queuing when opening actions while another modal is already open</li>
<li>Fix crash when a select modal is opened with a very long option</li>
</ul>
<h2 id="320---2025-06-20"><a class="header" href="#320---2025-06-20">[3.2.0] - 2025-06-20</a></h2>
<h3 id="added-5"><a class="header" href="#added-5">Added</a></h3>
<ul>
<li>Add config field <code>follow_redirects</code> to enable/disable following 3xx redirects (enabled by default)
<ul>
<li>The behavior has always been to follow redirects, so this adds the ability to disable that globally</li>
<li><strong>Reminder:</strong> Global configuration is not automatically reloaded. After making changes to your <code>config.yml</code>, you'll need to restart Slumber for changes to take effect</li>
<li><a href="https://slumber.lucaspickering.me/book/api/configuration/index.html#follow_redirects">See docs for more</a></li>
</ul>
</li>
<li>Add optional <code>target</code> argument to <code>slumber show paths</code> to show just a single path
<ul>
<li>E.g. <code>slumber show paths config</code> prints just the config path</li>
</ul>
</li>
<li>Add <code>--edit</code> flag to <code>slumber show config</code> and <code>slumber show collection</code>
<ul>
<li>This will open the global config/collection file in your configured editor, similar to <code>git config --edit</code></li>
</ul>
</li>
<li><code>slumber import</code> now supports importing from stdin or a URL
<ul>
<li>If no input argument is given, it will read from stdin, e.g. <code>slumber import openapi &lt; openapi.json</code></li>
<li>If a URL is given, the file will be downloaded and imported, e.g. <code>slumber import openapi https://example.com/openapi.json</code></li>
</ul>
</li>
<li>Add OpenAPI v3.1 importer <a href="https://github.com/LucasPickering/slumber/issues/513">#513</a></li>
</ul>
<h3 id="changed-4"><a class="header" href="#changed-4">Changed</a></h3>
<ul>
<li>Any top-level fields in the config or collection file beginning with <code>.</code> will now be ignored
<ul>
<li>The goal is to support "hidden" fields to store reusable components. YAML aliases can be used to pull those components into various parts of your collection</li>
<li>Previously the field <code>.ignore</code> was specially supported in the collection format for this purpose; this is a generalization of that special case.</li>
</ul>
</li>
</ul>
<h2 id="fixed-4"><a class="header" href="#fixed-4">Fixed</a></h2>
<ul>
<li>Import JSON bodies from OpenAPI spec operations that don't have an <code>example</code> field
<ul>
<li>Now it will infer a body from the schema definition if no examples are provided</li>
</ul>
</li>
<li>Fix occasional hang when opening <code>fx</code> as a pager <a href="https://github.com/LucasPickering/slumber/issues/506">#506</a></li>
</ul>
<h2 id="313---2025-06-07"><a class="header" href="#313---2025-06-07">[3.1.3] - 2025-06-07</a></h2>
<h3 id="fixed-5"><a class="header" href="#fixed-5">Fixed</a></h3>
<ul>
<li>Fix pager view action (regression in 3.1.2)</li>
<li>Fully restore terminal before exiting to editor/pager
<ul>
<li>This means any stdout/stderr that the external process writes will be properly formatted in the terminal</li>
</ul>
</li>
</ul>
<h2 id="312---2025-05-30"><a class="header" href="#312---2025-05-30">[3.1.2] - 2025-05-30</a></h2>
<h3 id="changed-5"><a class="header" href="#changed-5">Changed</a></h3>
<ul>
<li>Use a dedicated error state if collection fails to load on TUI launch</li>
<li>Update dependency <code>persisted</code> to 1.0
<ul>
<li>A few pieces of your UI state, such as selected tabs, will be lost during the upgrade due to this</li>
</ul>
</li>
</ul>
<h3 id="fixed-6"><a class="header" href="#fixed-6">Fixed</a></h3>
<ul>
<li>Fix TUI crash when using an empty select list</li>
<li>Fix automatic collection reloading in Windows
<ul>
<li>I don't use Windows so I'm not sure exactly what scenarios it may have been broken in, but new unit tests indicate it's working now</li>
</ul>
</li>
<li>Fix config loading failing for read-only config files (<a href="https://github.com/LucasPickering/slumber/issues/504">#504</a>)</li>
</ul>
<h2 id="311---2025-04-23"><a class="header" href="#311---2025-04-23">[3.1.1] - 2025-04-23</a></h2>
<h3 id="fixed-7"><a class="header" href="#fixed-7">Fixed</a></h3>
<ul>
<li>Persist response query commands separately for each content type
<ul>
<li>This prevents commands from running on the incorrect content type when the response type changes</li>
</ul>
</li>
</ul>
<h2 id="310---2025-04-04"><a class="header" href="#310---2025-04-04">[3.1.0] - 2025-04-04</a></h2>
<p>This releases focuses on history and data management. A suite of new features and improvements make it easy to disable request persistence and delete past requests from history.</p>
<h3 id="added-6"><a class="header" href="#added-6">Added</a></h3>
<ul>
<li>Add <code>--persist</code> flag to <code>slumber request</code>
<ul>
<li>By default, CLI-based requests are not stored in the history database. Use this flag to enable persistence for the sent request.</li>
</ul>
</li>
<li>Add <code>slumber history delete</code> subcommand for deleting request history</li>
<li>Add <code>slumber db</code> subcommand to open a shell to the local SQLite database</li>
<li>Add <code>persist</code> field to the global config and individual recipes
<ul>
<li>Both default to <code>true</code>, but you can now set them to <code>false</code> to disable data persistence a single recipe, or all instances of the app. <a href="https://slumber.lucaspickering.me/book/user_guide/database.html#controlling-persistence">See here for more</a></li>
</ul>
</li>
<li>Add actions to delete requests from the TUI
<ul>
<li>Delete a single request from the history modal or the Request/Response pane</li>
<li>Delete all requests for a recipe from the Recipe List/Recipe panes</li>
</ul>
</li>
</ul>
<h3 id="changed-6"><a class="header" href="#changed-6">Changed</a></h3>
<ul>
<li>Upgrade to Rust 1.86 (2024 edition!)</li>
<li>Improve functionality of <code>slumber history list</code>
<ul>
<li><code>recipe</code> argument is optional now. Omit it to show requests for all recipes in the current collection</li>
<li>Add <code>--all</code> argument to show requests for all collections</li>
<li>Add <code>--id-only</code> flag to print only IDs with no headers. Combine with <code>slumber history delete</code> for great success!</li>
</ul>
</li>
<li>Improve format of <code>slumber history list</code> table output</li>
</ul>
<h3 id="fixed-8"><a class="header" href="#fixed-8">Fixed</a></h3>
<ul>
<li>Fix output format of <code>slumber request --dry-run ...</code> to match <code>slumber request --verbose</code></li>
<li>Fix <code>curl</code> output for URL-encoded and multipart forms</li>
<li>Fix selected request not changing when profile changes</li>
</ul>
<h2 id="301---2025-02-19"><a class="header" href="#301---2025-02-19">[3.0.1] - 2025-02-19</a></h2>
<h3 id="fixed-9"><a class="header" href="#fixed-9">Fixed</a></h3>
<ul>
<li>Text box now scrolls to the cursor when it's off screen</li>
<li>Fix panics when the screen gets very small <a href="https://github.com/LucasPickering/slumber/issues/469">#469</a></li>
</ul>
<h2 id="300---2025-02-15"><a class="header" href="#300---2025-02-15">[3.0.0] - 2025-02-15</a></h2>
<p>A major release! The main focus of this release is the introduction of shell commands for data querying and export. Previously, you could query response bodies within the TUI only using JSONPath. This limited querying only to JSON responses, and the limited amount of operators supported by JSON. Now, you can use whatever shell commands you want (such as <code>head</code>, <code>grep</code>, and <code>jq</code>) to filter your reponses bodies, right in the TUI! <a href="https://slumber.lucaspickering.me/book/user_guide/tui/filter_query.md">Check out the docs</a> for more examples.</p>
<p>In addition to the querying change, this release includes a handful of breaking changes, none of which are likely to cause issues for existing users.</p>
<h3 id="breaking-1"><a class="header" href="#breaking-1">Breaking</a></h3>
<ul>
<li>Don't store CLI requests in history</li>
<li>Simplify display for <code>slumber request</code>
<ul>
<li>The flags <code>--status</code>, <code>--headers</code> and <code>--no-body</code> have been removed in favor of a single <code>--verbose</code> flag</li>
</ul>
</li>
<li>Remove DB migration to upgrade from the pre-1.8.0 DB format
<ul>
<li>This only impacts users upgrading to 3.0.0 from versions <em>before</em> 1.8.0. You'll need to upgrade to an intermediate version first. If you install 3.0.0 and try to start it, you'll see an error message explaining how to fix it.</li>
<li>See <a href="https://github.com/LucasPickering/slumber/issues/306">#306</a> for more info</li>
</ul>
</li>
</ul>
<h3 id="added-7"><a class="header" href="#added-7">Added</a></h3>
<ul>
<li>Replace JSONPath querying with general purpose shell commands for querying response bodies. <a href="https://slumber.lucaspickering.me/book/user_guide/tui/filter_query.md">See docs</a>
<ul>
<li>Now you can access any CLI tools you want for transforming response bodies, such as <code>jq</code> or <code>grep</code></li>
<li>By default, commands are executed via <code>sh</code> (or <code>cmd</code> on Windows), but this is configured via the <a href="https://slumber.lucaspickering.me/book/api/configuration/index.html"><code>commands.shell</code> field</a></li>
</ul>
</li>
<li>Add keybind (<code>:</code> by default) to run an "export" command with a response body, allowing you to run arbitrary shell commands to save a response body to a file, copy it to the clipboard, etc. <a href="https://slumber.lucaspickering.me/book/user_guide/tui/filter_query.md#exporting-data">See docs</a></li>
<li>Add <code>slumber history</code> subcommand. Currently it has two operations:
<ul>
<li><code>slumber history list</code> lists all stored requests for a recipe</li>
<li><code>slumber history get</code> prints a specific request/response</li>
</ul>
</li>
<li>Add <code>--output</code> flag to <code>slumber request</code> to control where the response body is written to</li>
<li>Support MIME type mapping for <code>pager</code> config field, so you can set different pagers based on media type. <a href="https://slumber.lucaspickering.me/book/api/configuration/mime.html">See docs</a></li>
<li>Several changes related to keybinds and action menus to make the two feel more cohesive
<ul>
<li>Add "Edit" and "Reset" actions to menus on the recipe pane
<ul>
<li>These don't provide any new functionality, as the <code>e</code> and <code>z</code> keys are already bound to those actions, but it should make them more discoverable</li>
</ul>
</li>
<li>Add keybind (<code>v</code> by defualt) to open a recipe/request/response body in your pager
<ul>
<li>Previously this was available only through the actions menu</li>
</ul>
</li>
<li>"View Body" and "Copy Body" actions for a <strong>recipe</strong> are now only available within the Body tab of the Recipe pane
<ul>
<li>Previously they were available anywhere in the Recipe List or Recipe panes. With the addition of other actions to the menu it was started to feel cluttered</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="changed-7"><a class="header" href="#changed-7">Changed</a></h3>
<ul>
<li>Denote templates that have been edited during the current session with italics instead of a faint "(edited)" note</li>
<li>Header names in recipes are now lowercased in the UI
<ul>
<li>They have always been lowercased when the request is actually sent, so now the UI is just more representative of what will be sent</li>
</ul>
</li>
<li>Accept a directory for the <code>--file</code>/<code>-f</code> CLI argument
<ul>
<li>If a directory is given, the <a href="https://slumber.lucaspickering.me/book/api/request_collection/index.html#format--loading">standard rules for detecting a collection file</a> will be applied from that directory</li>
</ul>
</li>
</ul>
<h3 id="fixed-10"><a class="header" href="#fixed-10">Fixed</a></h3>
<ul>
<li>Fix certain recipe-related menu actions being enabled when they shouldn't be</li>
</ul>
<h2 id="250---2025-01-06"><a class="header" href="#250---2025-01-06">[2.5.0] - 2025-01-06</a></h2>
<h3 id="added-8"><a class="header" href="#added-8">Added</a></h3>
<ul>
<li>Add REST Importer for VSCode and Jetbrains <a href="https://github.com/LucasPickering/slumber/issues/122">#122</a> (thanks @benfaerber)</li>
</ul>
<h3 id="changed-8"><a class="header" href="#changed-8">Changed</a></h3>
<ul>
<li>Update <a href="https://crates.io/crates/editor-command">editor-command</a>, which replaces <a href="https://crates.io/crates/shellish_parse">shellish_parse</a> with <a href="https://crates.io/crates/shell-words">shell-words</a> for editor and pager command parsing
<ul>
<li>There should be no impact to users</li>
</ul>
</li>
<li>Don't show "Loaded collection from ..." notification on initial load</li>
</ul>
<h2 id="240---2024-12-27"><a class="header" href="#240---2024-12-27">[2.4.0] - 2024-12-27</a></h2>
<h3 id="added-9"><a class="header" href="#added-9">Added</a></h3>
<ul>
<li>Add filter box to the recipe list
<ul>
<li>This behavior is not necessarily final. Please leave feedback if you think it could be improved.</li>
</ul>
</li>
</ul>
<h3 id="changed-9"><a class="header" href="#changed-9">Changed</a></h3>
<ul>
<li>Wrap long error messages in response pane</li>
<li>Include data path in config/collection deserialization errors
<ul>
<li>This should make errors much less cryptic and frustrating</li>
</ul>
</li>
<li>Improve UX of query text box
<ul>
<li>The query is now auto-applied when changed (with a 500ms debounce), and drops focus on the text box when Enter is pressed</li>
</ul>
</li>
<li>Refactor UI event handling logic
<ul>
<li>This shouldn't have any noticable impact on the user, but if you notice any bugs please open an issue</li>
</ul>
</li>
<li>Include request duration in History modal</li>
<li>Rename <code>viewer</code> config field to <code>pager</code>
<ul>
<li>The old field name <code>viewer</code> is still supported for backward compatibility, but the docs have been updated to suggest the newer name instead</li>
</ul>
</li>
<li>Load pager command from the <code>PAGER</code> environment variable if available, similar to the <code>EDITOR</code> environment variable</li>
</ul>
<h3 id="fixed-11"><a class="header" href="#fixed-11">Fixed</a></h3>
<ul>
<li>Don't show request cancellation dialog if the selected request isn't building/loading</li>
</ul>
<h2 id="230---2024-11-11"><a class="header" href="#230---2024-11-11">[2.3.0] - 2024-11-11</a></h2>
<h3 id="added-10"><a class="header" href="#added-10">Added</a></h3>
<ul>
<li>Add "View Body" action to response bodies, to open a body in an external viewer such as <code>less</code> or <code>fx</code> <a href="https://github.com/LucasPickering/slumber/issues/404">#404</a>
<ul>
<li>By default <code>less</code> is used. You can customize this with the <a href="https://slumber.lucaspickering.me/book/api/configuration/editor.html"><code>viewer</code> config field</a></li>
</ul>
</li>
</ul>
<h3 id="changed-10"><a class="header" href="#changed-10">Changed</a></h3>
<ul>
<li>Preserve key order of objects in JSON responses <a href="https://github.com/LucasPickering/slumber/issues/405">#405</a></li>
</ul>
<h3 id="fixed-12"><a class="header" href="#fixed-12">Fixed</a></h3>
<ul>
<li>Fixed <code>ignore_certificate_hosts</code> and <code>large_body_size</code> fields not being loaded from config</li>
<li>Improve performance of large response bodies <a href="https://github.com/LucasPickering/slumber/issues/356">#356</a>
<ul>
<li>This includes disabling prettyification and syntax highlighting on bodies over 1 MB (this size is configurable, via the <code>large_body_size</code> <a href="https://slumber.lucaspickering.me/book/api/configuration/index.html">config field</a>)</li>
<li>Loading a large response body should no longer cause the UI to freeze or low framerate</li>
</ul>
</li>
</ul>
<h2 id="220---2024-10-22"><a class="header" href="#220---2024-10-22">[2.2.0] - 2024-10-22</a></h2>
<h3 id="added-11"><a class="header" href="#added-11">Added</a></h3>
<ul>
<li>Add shell completions, accessed by enabling the <code>COMPLETE</code> environment variable
<ul>
<li>For example, adding <code>COMPLETE=fish slumber | source</code> to your <code>fish.config</code> will enable completions for fish</li>
<li><a href="https://slumber.lucaspickering.me/book/troubleshooting/shell_completions.html">See docs</a> for more info and a list of supported shells</li>
</ul>
</li>
<li>Add <code>slumber gen</code> alias to <code>--help</code> documentation</li>
</ul>
<h3 id="fixed-13"><a class="header" href="#fixed-13">Fixed</a></h3>
<ul>
<li>Fix error loading requests with empty header values from history <a href="https://github.com/LucasPickering/slumber/issues/400">#400</a></li>
<li>Fix input bindings involving <code>shift</code> and a character (e.g. <code>shift g</code>) <a href="https://github.com/LucasPickering/slumber/issues/401">#401</a></li>
</ul>
<h2 id="210---2024-09-27"><a class="header" href="#210---2024-09-27">[2.1.0] - 2024-09-27</a></h2>
<h3 id="added-12"><a class="header" href="#added-12">Added</a></h3>
<ul>
<li>Use <code>SLUMBER_CONFIG_PATH</code> to customize configuration (<em>not</em> collection) file path <a href="https://github.com/LucasPickering/slumber/issues/370">#370</a></li>
<li>Add a dynamic variant to <code>!select</code> chain type, allowing your collection to present a list of values driven from the output of another chain. (thanks @anussel5559)
<ul>
<li><a href="https://slumber.lucaspickering.me/book/api/request_collection/chain_source.html#select">See docs for more</a></li>
</ul>
</li>
<li>Cancel in-flight requests with the <code>cancel</code> action (bound to escape by default)</li>
<li>Add <code>slumber new</code> subcommand to generate new collection files <a href="https://github.com/LucasPickering/slumber/issues/376">#376</a></li>
<li>Add <code>default</code> field to profiles
<ul>
<li>When using the CLI, the <code>--profile</code> argument can be omitted to use the default profile</li>
</ul>
</li>
<li>Reset edited recipe values to their default using <code>z</code>
<ul>
<li>You can <a href="https://slumber.lucaspickering.me/book/api/configuration/input_bindings.html">customize the key</a> to whatever you want</li>
</ul>
</li>
<li>Add <code>selector_mode</code> field to chains, to control how single vs multiple results from a JSONPath selector are handled
<ul>
<li>Previously, if a selector returned multiple results, an error was returned. Now, the result list will be rendered as a JSON array. To return to the previous behavior, set <code>selector_mode: single</code> in your chain.</li>
<li><a href="https://slumber.lucaspickering.me/book/api/request_collection/chain.html#selector-mode">See docs for more</a></li>
</ul>
</li>
</ul>
<h3 id="changed-11"><a class="header" href="#changed-11">Changed</a></h3>
<ul>
<li>Update file locations to adhere to XDG spec on Linux <a href="https://github.com/LucasPickering/slumber/issues/371">#371</a>
<ul>
<li>Move config file to <a href="https://docs.rs/dirs/latest/dirs/fn.config_dir.html">config dir</a>, which remains the same on MacOS/Windows but changes on Linux. For backward compatibility, the previous path (<a href="https://docs.rs/dirs/latest/dirs/fn.data_dir.html">data dir</a>) will be checked and used if present</li>
<li>Move log files to <a href="https://docs.rs/dirs/latest/dirs/fn.state_dir.html">state dir</a> on Linux and <a href="https://docs.rs/dirs/latest/dirs/fn.cache_dir.html">cache dir</a> on MacOS/Windows</li>
<li>Database file remains in <a href="https://docs.rs/dirs/latest/dirs/fn.data_dir.html">data dir</a> on all platforms</li>
</ul>
</li>
<li>Create config file on startup if it doesn't exist</li>
<li>If config file fails to load during TUI startup, display an error and fall back to the default, rather than crashing</li>
<li>De-deprecate <code>{{env.VARIABLE}}</code> template sources
<ul>
<li>They'll remain as a simpler alternative to <code>!env</code> chains</li>
</ul>
</li>
</ul>
<h3 id="fixed-14"><a class="header" href="#fixed-14">Fixed</a></h3>
<ul>
<li>Updated the Configuration docs to remove the non-existent <code>slumber show dir</code> command (thanks @SVendittelli)</li>
<li>Retain all request history when collection file is reloaded
<ul>
<li>Previously, pending and failed requests were lost on reload within a single session. These will still be lost when a session is exited.</li>
</ul>
</li>
<li>Fix serialization of query parameter lists</li>
<li>Don't update UI for useless events (e.g. cursor moves)</li>
</ul>
<h2 id="200---2024-09-06"><a class="header" href="#200---2024-09-06">[2.0.0] - 2024-09-06</a></h2>
<p>2.0 is headlined by a highly requested feature: one-off edits to recipes! If you need to tweak a query parameter or edit a body, but don't want to modify your collection file, you can now highlight the value in question and hit <code>e</code> to modify it. The override will be retained until you modify the collection file or exit Slumber, at which point it will revert to its original value.</p>
<p>Aside from the major new feature, there is one breaking change to the escape syntax of templates. The old backslash-based syntax was fraught with edge cases and unpredictable behavior. This new syntax is simpler to use, simpler to implement, and much more bulletproof. This syntax was rare to use to begin with, so <strong>most people will be unimpacted by this change.</strong></p>
<p>Here's the full list of changes:</p>
<h3 id="breaking-2"><a class="header" href="#breaking-2">Breaking</a></h3>
<ul>
<li>Replace backslash escape sequence with a simpler scheme based on <code>_</code>
<ul>
<li>For example, previously a key would be escaped as <code>\{{</code>. This introduced complexities around how to handle additional backslashes, and also required doubling up backslashes in YAML</li>
<li>The new equivalent would be <code>{_{</code>, which parses as <code>{{</code></li>
<li>The goal of this change is to make escaping behavior simpler and more consistent</li>
<li>For more info on the new behavior, <a href="https://slumber.lucaspickering.me/book/api/request_collection/template.html#escape-sequences">see the docs</a></li>
</ul>
</li>
<li>Remove <code>--log</code> CLI argument
<ul>
<li>See note on log files in Changed section for why this is no longer necessary</li>
</ul>
</li>
</ul>
<h3 id="added-13"><a class="header" href="#added-13">Added</a></h3>
<ul>
<li>Edit recipe values (query params, headers, etc.) in the TUI to provide one-off values
<ul>
<li>Press <code>e</code> on any value you want to edit (you can <a href="https://slumber.lucaspickering.me/book/api/configuration/input_bindings.html">customize the key</a>)</li>
</ul>
</li>
<li>Add <code>editor</code> field to the config, allowing you to customize what editor Slumber opens for in-app editing
<ul>
<li><a href="https://slumber.lucaspickering.me/book/api/configuration/editor.html">See docs for more</a></li>
</ul>
</li>
<li>Add <code>!select</code> chain type, allowing your collection to prompt the user to select a value from a static list (thanks @anussel5559)
<ul>
<li><a href="https://slumber.lucaspickering.me/book/api/request_collection/chain_source.html#select">See docs for more</a></li>
</ul>
</li>
</ul>
<h3 id="changed-12"><a class="header" href="#changed-12">Changed</a></h3>
<ul>
<li><code>!json</code> bodies are now prettified when sent to the server</li>
<li>Use <code>vim</code> as default editor if none is configured</li>
<li>Move logs back to a shared file
<ul>
<li>They had been split into one file per session, which made them hard to find</li>
<li>The file is now eventually deleted once it exceeds a certain size</li>
</ul>
</li>
</ul>
<h3 id="fixed-15"><a class="header" href="#fixed-15">Fixed</a></h3>
<ul>
<li>Fix basic auth being label as bearer auth in Recipe Authentication pane</li>
<li>Use correct binding for <code>search</code> action in the placeholder of the response filter textbox
<ul>
<li>Previously it was hardcoded to display the default of <code>/</code></li>
</ul>
</li>
<li>Fix response body filter not applying on new responses</li>
<li>Support quoted arguments in editor commands</li>
<li>Fix certain UI values not persisting correctly</li>
<li>Propagate unconsumed key events from text boxes
<ul>
<li>E.g. F5 will now refresh the collection while a text box is in focus</li>
</ul>
</li>
<li>Redraw TUI when terminal is resized</li>
<li>Clamp text window scroll state when window is resized or text changes</li>
<li>Fix extraneous input events when exiting Vim <a href="https://github.com/LucasPickering/slumber/issues/351">#351</a></li>
<li>Improve performance and fix crashes when handling large request/response bodies <a href="https://github.com/LucasPickering/slumber/issues/356">#356</a>
<ul>
<li>Further improvements for large bodies will be coming in the future</li>
</ul>
</li>
</ul>
<h2 id="181---2024-08-11"><a class="header" href="#181---2024-08-11">[1.8.1] - 2024-08-11</a></h2>
<p>This release is focused on improving rendering performance. The TUI should generally feel more polished and responsive when working with large bodies, and CPU usage will be much lower.</p>
<h3 id="added-14"><a class="header" href="#added-14">Added</a></h3>
<ul>
<li>Add <code>debug</code> configuration field, to enable developer information</li>
</ul>
<h3 id="fixed-16"><a class="header" href="#fixed-16">Fixed</a></h3>
<ul>
<li>Reduce CPU usage while idling
<ul>
<li>Previously, Slumber would re-render every 250ms while idling, which could lead to high CPU usage, depending on what's on the screen. Now it will only update when changes occur, meaning idle CPU usage will be nearly 0</li>
</ul>
</li>
<li>Fix backlogged events when renders are slow
<ul>
<li>If renders are being particular slow, it was previously possible for input events (e.g. repeated scrolling events) to occur faster than the UI could keep up. This would lead to "lock out" behavior, where you'd stop scrolling and it'd take a while for the UI to catch up.</li>
<li>Now, the TUI will skip draws as necessary to keep up with the input queue. In practice the skipping should be hard to notice as it only occurs during rapid TUI movements anyway.</li>
</ul>
</li>
<li>Improve rendering performance for large bodies and syntax highlighting</li>
<li>Fix incorrect decoration in folder tree visualization</li>
</ul>
<h2 id="180---2024-08-09"><a class="header" href="#180---2024-08-09">[1.8.0] - 2024-08-09</a></h2>
<p>The highlight (no pun intended) of this release is syntax highlighting. Beyond that, the release contains a variety of small fixes and improvements.</p>
<h3 id="added-15"><a class="header" href="#added-15">Added</a></h3>
<ul>
<li>Add syntax highlighting to recipe, request, and response display <a href="https://github.com/LucasPickering/slumber/issues/264">#264</a></li>
</ul>
<h3 id="changed-13"><a class="header" href="#changed-13">Changed</a></h3>
<ul>
<li>Change layout of internal database for request and UI state storage
<ul>
<li>This <em>shouldn't</em> have any user impact, it's just a technical improvement. If you notice any issues such as missing or incorrect request history, please <a href="https://github.com/LucasPickering/slumber/issues/new?assignees=&amp;labels=bug&amp;projects=&amp;template=bug_report.md">let me know</a></li>
</ul>
</li>
<li>Upgrade to Rust 1.80</li>
<li>Disable unavailable menu actions <a href="https://github.com/LucasPickering/slumber/issues/222">#222</a></li>
<li>Support template for header names in the <code>section</code> field of <code>!request</code> chains</li>
<li>Expand <code>~</code> to the home directory in <code>!file</code> chain sources and when saving response body as a file</li>
<li>Ignore key events with additional key modifiers
<ul>
<li>For example, an action bound to <code>w</code> will no longer match <code>ctrl w</code></li>
</ul>
</li>
<li>Actions can now be unbound by specifying an empty binding
<ul>
<li>For example, binding <code>submit: []</code> will make the submit action inaccessible</li>
</ul>
</li>
</ul>
<h3 id="fixed-17"><a class="header" href="#fixed-17">Fixed</a></h3>
<ul>
<li>Fix <code>cargo install slumber</code> when not using <code>--locked</code></li>
<li>Don't type in text boxes when modifiers keys (other than shift) are enabled
<ul>
<li>Should mitigate some potential confusing behavior when using terminal key sequences</li>
</ul>
</li>
<li>Query parameter and header toggle rows no longer lose their state when switching profiles</li>
</ul>
<h2 id="170---2024-07-22"><a class="header" href="#170---2024-07-22">[1.7.0] - 2024-07-22</a></h2>
<p>This release focuses on minor fixes and improvements. There are no new major features or added functionality.</p>
<h3 id="added-16"><a class="header" href="#added-16">Added</a></h3>
<ul>
<li>Add global <code>--log</code> argument to CLI, to print the log file being used for that invocation</li>
</ul>
<h3 id="changed-14"><a class="header" href="#changed-14">Changed</a></h3>
<ul>
<li>Checkbox row state and folder expand/collapse state are now toggled via the spacebar instead of enter
<ul>
<li>Enter now sends a request from anywhere. While this change may be annoying, it will hopefully be more intuitive in the long run.</li>
<li>This can be rebound (<a href="https://slumber.lucaspickering.me/book/api/configuration/input_bindings.html">see docs</a>)</li>
</ul>
</li>
<li>Show folder tree in recipe pane when a folder is selected</li>
<li>Don't exit body filter text box on Enter <a href="https://github.com/LucasPickering/slumber/issues/270">#270</a></li>
<li>Show elapsed time for failed requests (e.g. in case of network error)</li>
</ul>
<h3 id="fixes"><a class="header" href="#fixes">Fixes</a></h3>
<ul>
<li>Fix latest request not being pre-selected correctly if it's not a successful response</li>
<li>Detect infinite loops in chain configuration templates</li>
<li>Duplicated chains in a recipe will only be rendered once <a href="https://github.com/LucasPickering/slumber/issues/118">#118</a></li>
<li>Never trigger chained requests when rendering template previews in the TUI</li>
<li>Use a different log file for each session <a href="https://github.com/LucasPickering/slumber/issues/61">#61</a></li>
</ul>
<h2 id="160---2024-07-07"><a class="header" href="#160---2024-07-07">[1.6.0] - 2024-07-07</a></h2>
<h3 id="added-17"><a class="header" href="#added-17">Added</a></h3>
<ul>
<li>Initial support for importing collections from an OpenAPIv3 specification <a href="https://github.com/LucasPickering/slumber/issues/106">#106</a>
<ul>
<li>Currently only OpenAPI 3.0 (not 3.1) is supported. Please try this out and give feedback if anything doesn't work.</li>
</ul>
</li>
</ul>
<h3 id="changed-15"><a class="header" href="#changed-15">Changed</a></h3>
<ul>
<li>Allow escaping keys in templates <a href="https://github.com/LucasPickering/slumber/issues/149">#149</a>
<ul>
<li>While this is technically a breaking change, this is not a major version bump because it's extremely unlikely that this will break anything in practice for a user</li>
<li><a href="https://slumber.lucaspickering.me/book/api/request_collection/template.html#escape-sequences">See docs</a></li>
</ul>
</li>
</ul>
<h3 id="fixed-18"><a class="header" href="#fixed-18">Fixed</a></h3>
<ul>
<li>Support TLS certificates in native certificate store <a href="https://github.com/LucasPickering/slumber/issues/275">#275</a></li>
</ul>
<h2 id="150---2024-06-17"><a class="header" href="#150---2024-06-17">[1.5.0] - 2024-06-17</a></h2>
<h3 id="added-18"><a class="header" href="#added-18">Added</a></h3>
<ul>
<li>Add <code>!env</code> chain source, for loading environment variables
<ul>
<li>This is intended to replace the existing <code>{{env.VARIABLE}}</code> syntax, which is now deprecated and will be removed in the future</li>
</ul>
</li>
</ul>
<h3 id="changed-16"><a class="header" href="#changed-16">Changed</a></h3>
<ul>
<li>"Edit Collection" action now uses the editor set in <code>$VISUAL</code>/<code>$EDITOR</code> instead of whatever editor you have set as default for <code>.yaml</code>/<code>.yml</code> files <a href="https://github.com/LucasPickering/slumber/issues/262">#262</a>
<ul>
<li>In most cases this means you'll now get <code>vim</code> instead of VSCode or another GUI editor</li>
<li>Closing the editor will return you to Slumber, meaning you can stay in the terminal the entire time</li>
</ul>
</li>
</ul>
<h3 id="fixed-19"><a class="header" href="#fixed-19">Fixed</a></h3>
<ul>
<li>Environment variables in <code>{{env.VARIABLE}}</code> templates are now loaded as strings according to the OS encoding, as opposed to always being decoded as UTF-8</li>
</ul>
<h2 id="140---2024-06-11"><a class="header" href="#140---2024-06-11">[1.4.0] - 2024-06-11</a></h2>
<h3 id="added-19"><a class="header" href="#added-19">Added</a></h3>
<ul>
<li>Structured bodies can now be defined with tags on the <code>body</code> field of a recipe, making it more convenient to construct bodies of common types. Supported types are:
<ul>
<li><code>!json</code> <a href="https://github.com/LucasPickering/slumber/issues/242">#242</a></li>
<li><code>!form_urlencoded</code> <a href="https://github.com/LucasPickering/slumber/issues/244">#244</a></li>
<li><code>!form_multipart</code> <a href="https://github.com/LucasPickering/slumber/issues/243">#243</a></li>
<li><a href="https://slumber.lucaspickering.me/book/api/request_collection/recipe_body.html">See docs</a> for usage instructions</li>
</ul>
</li>
<li>Support multiple instances of the same query param <a href="https://github.com/LucasPickering/slumber/issues/245">#245</a> (@maksimowiczm)
<ul>
<li>Query params can now be defined as a list of <code>&lt;param&gt;=&lt;value&gt;</code> entries</li>
<li><a href="https://slumber.lucaspickering.me/book/api/request_collection/query_parameters.html">See docs</a></li>
</ul>
</li>
<li>Templates can now render binary values in certain contexts
<ul>
<li><a href="https://slumber.lucaspickering.me/book/user_guide/templates.html#binary-templates">See docs</a></li>
</ul>
</li>
</ul>
<h3 id="changed-17"><a class="header" href="#changed-17">Changed</a></h3>
<ul>
<li>When a modal/dialog is open <code>q</code> now exits the dialog instead of the entire app</li>
<li>Upgrade to Rust 1.76</li>
</ul>
<h3 id="fixed-20"><a class="header" href="#fixed-20">Fixed</a></h3>
<ul>
<li>Fix "Unknown request ID" error showing on startup <a href="https://github.com/LucasPickering/slumber/issues/238">#238</a></li>
</ul>
<h2 id="132---2024-05-27"><a class="header" href="#132---2024-05-27">[1.3.2] - 2024-05-27</a></h2>
<h3 id="changed-18"><a class="header" href="#changed-18">Changed</a></h3>
<ul>
<li>Show "Copy URL", "Copy Body" and "Copy as cURL" actions from the Recipe list <a href="https://github.com/LucasPickering/slumber/issues/224">#224</a>
<ul>
<li>Previously this was only available in the Recipe detail pane</li>
</ul>
</li>
<li>Fix Edit Collection action in menu</li>
<li>Persist response body query text box contents
<ul>
<li>Previously it would reset whenever you made a new request or changed recipes</li>
</ul>
</li>
</ul>
<h2 id="131---2024-05-21"><a class="header" href="#131---2024-05-21">[1.3.1] - 2024-05-21</a></h2>
<h3 id="fixed-21"><a class="header" href="#fixed-21">Fixed</a></h3>
<ul>
<li>Fix double key events on Windows <a href="https://github.com/LucasPickering/slumber/issues/226">#226</a></li>
</ul>
<h2 id="130---2024-05-17"><a class="header" href="#130---2024-05-17">[1.3.0] - 2024-05-17</a></h2>
<p>The biggest feature in this release is the ability to browse request history. Slumber has already had the ability to <em>track</em> history, meaning all your history since you started using it will already be there! In addition, this release contains some UI improvements, as well as some pretty major internal refactors to enable these UI changes. These will also make future UI improvements easier and faster to implement.</p>
<h3 id="added-20"><a class="header" href="#added-20">Added</a></h3>
<ul>
<li>Request history is now browsable! <a href="https://github.com/LucasPickering/slumber/issues/55">#55</a></li>
<li>Add scrollbars to lists and text windows <a href="https://github.com/LucasPickering/slumber/issues/220">#220</a></li>
</ul>
<h3 id="changed-19"><a class="header" href="#changed-19">Changed</a></h3>
<ul>
<li>Merge request &amp; response panes
<ul>
<li>The request pane often isn't needed, so it doesn't deserve top-level space</li>
</ul>
</li>
<li>Mouse events (e.g. scrolling) are now sent to unfocused elements</li>
</ul>
<h2 id="121---2024-05-11"><a class="header" href="#121---2024-05-11">[1.2.1] - 2024-05-11</a></h2>
<h3 id="fixed-22"><a class="header" href="#fixed-22">Fixed</a></h3>
<ul>
<li>Fix profile not being selected on initial startup</li>
</ul>
<h2 id="120---2024-05-10"><a class="header" href="#120---2024-05-10">[1.2.0] - 2024-05-10</a></h2>
<h3 id="added-21"><a class="header" href="#added-21">Added</a></h3>
<ul>
<li>Add <code>trim</code> option to chains, to trim leading/trailing whitespace <a href="https://github.com/LucasPickering/slumber/issues/153">#153</a>
<ul>
<li><a href="https://slumber.lucaspickering.me/book/api/request_collection/chain.html#chain-output-trim">See docs</a></li>
</ul>
</li>
</ul>
<h3 id="changed-20"><a class="header" href="#changed-20">Changed</a></h3>
<ul>
<li>Use colored background for status codes
<ul>
<li>This includes a new theme field, <code>success_color</code></li>
</ul>
</li>
<li>Improve hierarchy presentation of errors</li>
<li>Convert profile list into a popup modal</li>
</ul>
<h3 id="fixed-23"><a class="header" href="#fixed-23">Fixed</a></h3>
<ul>
<li>Exit fullscreen mode when changing panes</li>
<li>Support scrolling on more lists/tables</li>
</ul>
<h2 id="110---2024-05-05"><a class="header" href="#110---2024-05-05">[1.1.0] - 2024-05-05</a></h2>
<h3 id="added-22"><a class="header" href="#added-22">Added</a></h3>
<ul>
<li>Add <code>section</code> field to <code>!request</code> chain values, to allow chaining response headers rather than body (<a href="https://github.com/LucasPickering/slumber/issues/184">#184</a>)</li>
<li>Add action to save response body to file (<a href="https://github.com/LucasPickering/slumber/issues/183">#183</a>)</li>
<li>Add <code>theme</code> field to the config, to configure colors (<a href="https://github.com/LucasPickering/slumber/issues/193">#193</a>)
<ul>
<li><a href="https://slumber.lucaspickering.me/book/api/configuration/theme.html">See docs</a> for more info</li>
</ul>
</li>
<li>Add <code>stdin</code> option to command chains (<a href="https://github.com/LucasPickering/slumber/issues/190">#190</a>)</li>
</ul>
<h3 id="changed-21"><a class="header" href="#changed-21">Changed</a></h3>
<ul>
<li>Reduce UI latency under certain scenarios
<ul>
<li>Previously some actions would feel laggy because of an inherent 250ms delay in processing some events</li>
</ul>
</li>
<li>Search parent directories for collection file (<a href="https://github.com/LucasPickering/slumber/issues/194">#194</a>)</li>
<li>Use thicker borders for selected pane and modals</li>
<li>Change default TUI colors to blue and yellow</li>
</ul>
<h3 id="fixed-24"><a class="header" href="#fixed-24">Fixed</a></h3>
<ul>
<li>Fix Slumber going into zombie mode and CPU spiking to 100% under certain closure scenarios (<a href="https://github.com/LucasPickering/slumber/issues/136">#136</a>)</li>
<li>Fix historical request/response no loading on first render (<a href="https://github.com/LucasPickering/slumber/issues/199">#199</a>)</li>
</ul>
<h2 id="101---2024-04-27"><a class="header" href="#101---2024-04-27">[1.0.1] - 2024-04-27</a></h2>
<h3 id="added-23"><a class="header" href="#added-23">Added</a></h3>
<ul>
<li>Add two new build targets to releases: <code>x86_64-pc-windows-msvc</code> and <code>x86_64-unknown-linux-musl</code></li>
</ul>
<h3 id="fixed-25"><a class="header" href="#fixed-25">Fixed</a></h3>
<ul>
<li>Fix build on Windows (<a href="https://github.com/LucasPickering/slumber/issues/180">#180</a>)
<ul>
<li>I can't guarantee it <em>works</em> on Windows since I don't have a machine to test on, but it at least compiles now</li>
</ul>
</li>
</ul>
<h2 id="100---2024-04-25"><a class="header" href="#100---2024-04-25">[1.0.0] - 2024-04-25</a></h2>
<h3 id="breaking-3"><a class="header" href="#breaking-3">Breaking</a></h3>
<ul>
<li>Rename collection file parameter on all CLI commands from <code>--collection</code>/<code>-c</code> to <code>--file</code>/<code>-f</code>
<ul>
<li>The goal here is to be more intuitive/predictable, since <code>-f</code> is much more common in similar programs (e.g. docker-compose)</li>
</ul>
</li>
</ul>
<h3 id="added-24"><a class="header" href="#added-24">Added</a></h3>
<ul>
<li>Support booleans and numbers for query values (<a href="https://github.com/LucasPickering/slumber/issues/141">#141</a>)</li>
<li>Add <code>default</code> field to <code>!prompt</code> chains, which allows setting a pre-populated value for the prompt textbox</li>
</ul>
<h3 id="changed-22"><a class="header" href="#changed-22">Changed</a></h3>
<ul>
<li>Folders can now be collapsed in the recipe list (<a href="https://github.com/LucasPickering/slumber/issues/155">#155</a>)</li>
<li>Improvements to Insomnia import (<a href="https://github.com/LucasPickering/slumber/issues/12">#12</a>)</li>
<li>Rename <code>import-experimental</code> command to <code>import</code>
<ul>
<li>It's official now! It's still going to get continued improvement though</li>
</ul>
</li>
<li>Show <code>WARN</code>/<code>ERROR</code> log output for CLI commands</li>
<li>Validate recipe <code>method</code> field during deserialization instead of on request init
<ul>
<li>This means you'll get an error on startup if your method is invalid, instead of when you go to run the request</li>
<li>This is not a breaking change because if you had an incorrect HTTP method, the request still didn't <em>work</em> before, it just broke later</li>
</ul>
</li>
<li>Arguments to chains are now treated as templates (<a href="https://github.com/LucasPickering/slumber/issues/151">#151</a>)
<ul>
<li>Support fields are <code>path</code> for <code>!file</code> chains, <code>command</code> for <code>!command</code> chains, and <code>message</code> for <code>!prompt</code> chains</li>
<li>This means you can now <em>really</em> chain chains together!</li>
</ul>
</li>
</ul>
<h2 id="0180---2024-04-18"><a class="header" href="#0180---2024-04-18">[0.18.0] - 2024-04-18</a></h2>
<h3 id="breaking-4"><a class="header" href="#breaking-4">Breaking</a></h3>
<ul>
<li>All existing recipes must be tagged with <code>!request</code> in the collection file
<ul>
<li>This is necessary to differentiate from the new <code>!folder</code> type</li>
</ul>
</li>
<li>Profile values are always treated as templates now
<ul>
<li>Any profile values that were previously the "raw" variant (the default) that contain template syntax (e.g. <code>{{user_id}}</code>) will now be rendered as templates. In reality this is very unlikely, so this probably isn't going to break your setup</li>
<li>If you have an existing profile value tagged with <code>!template</code> it <strong>won't</strong> break, but it will no longer do anything</li>
</ul>
</li>
<li>Unknown fields in config/collection files will now be rejected (<a href="https://github.com/LucasPickering/slumber/issues/154">#154</a>)
<ul>
<li>In most cases this field is a mistake, so this is meant to make debugging easier</li>
<li>If you have an intentional unknown field, you can now nest it under <code>.ignore</code> to ignore it</li>
</ul>
</li>
<li>Replace <code>slumber show dir</code> with <code>slumber show paths</code></li>
</ul>
<h3 id="added-25"><a class="header" href="#added-25">Added</a></h3>
<ul>
<li>Request recipes can now be organized into folders (<a href="https://github.com/LucasPickering/slumber/issues/60">#60</a>)
<ul>
<li>See <a href="https://slumber.lucaspickering.me/book/api/request_collection/request_recipe.html#folder-fields">the docs</a> for usage examples</li>
</ul>
</li>
<li>Add <code>slumber show config</code> and <code>slumber show collection</code> subcommands</li>
</ul>
<h3 id="changed-23"><a class="header" href="#changed-23">Changed</a></h3>
<ul>
<li>Prevent infinite recursion in templates
<ul>
<li>It now triggers a helpful error instead of a panic</li>
</ul>
</li>
<li>Support additional key codes for input mapping, including media keys</li>
</ul>
<h3 id="fixed-26"><a class="header" href="#fixed-26">Fixed</a></h3>
<ul>
<li>Multiple spaces between modifiers/key codes in a key combination are now ignored</li>
</ul>
<h2 id="0170---2024-04-08"><a class="header" href="#0170---2024-04-08">[0.17.0] - 2024-04-08</a></h2>
<h3 id="breaking-5"><a class="header" href="#breaking-5">Breaking</a></h3>
<ul>
<li>All variants of the <code>Chain.source</code> field are now maps
<ul>
<li>This is to support the next request auto-execution feature, as well as future proofing for additional chain configuration</li>
</ul>
</li>
<li>Remove <code>send_request</code> keybinding
<ul>
<li>The <code>submit</code> keybinding is now used to send requests from all panes (except the profile pane)</li>
<li>This is only a breaking change if you have <code>send_request</code> remapped in your config file</li>
</ul>
</li>
</ul>
<p>Follow this mapping to update:</p>
<pre><code class="language-yaml"># Before
chains:
  auth_token:
    source: !request login
  username:
    source: !command ["echo", "-n", "hello"]
  username:
    source: !file ./username.txt
  password:
    source: !prompt Enter Password
---
# After
chains:
  auth_token:
    source: !request
      recipe: login
  username:
    source: !command
      command: ["echo", "-n", "hello"]
  username:
    source: !file
      path: ./username.txt
  password:
    source: !prompt
      message: Enter Password
</code></pre>
<h3 id="added-26"><a class="header" href="#added-26">Added</a></h3>
<ul>
<li>Chained requests can now be auto-executed according to various criteria (<a href="https://github.com/LucasPickering/slumber/issues/140">#140</a>)
<ul>
<li>See <a href="https://slumber.lucaspickering.me/book/user_guide/chaining_requests.html">the docs</a> for more</li>
</ul>
</li>
<li>Add Authentication tab to recipe pane (<a href="https://github.com/LucasPickering/slumber/issues/144">#144</a>)</li>
</ul>
<h3 id="changed-24"><a class="header" href="#changed-24">Changed</a></h3>
<ul>
<li>Don't print full stack trace for failed CLI commands</li>
<li>Disable formatting and highlighting for response bodies over 1MB (size threshold customizable <a href="https://slumber.lucaspickering.me/book/api/configuration/index.html">in the config</a>)</li>
</ul>
<h3 id="fixes-1"><a class="header" href="#fixes-1">Fixes</a></h3>
<ul>
<li>Improve performance of handling large response bodies</li>
</ul>
<h2 id="0160---2024-04-01"><a class="header" href="#0160---2024-04-01">[0.16.0] - 2024-04-01</a></h2>
<h3 id="added-27"><a class="header" href="#added-27">Added</a></h3>
<ul>
<li>Add support for custom keybindings (<a href="https://github.com/LucasPickering/slumber/issues/137">#137</a>)</li>
</ul>
<h3 id="fixed-27"><a class="header" href="#fixed-27">Fixed</a></h3>
<ul>
<li>Fix request body not updating in UI when changing recipe</li>
</ul>
<h2 id="0150---2024-03-24"><a class="header" href="#0150---2024-03-24">[0.15.0] - 2024-03-24</a></h2>
<h3 id="added-28"><a class="header" href="#added-28">Added</a></h3>
<ul>
<li>Add horizontal scrolling to response body (<a href="https://github.com/LucasPickering/slumber/issues/111">#111</a>)
<ul>
<li>Use shift+left and shift+right</li>
</ul>
</li>
<li>Add app version to help modal</li>
<li>Add "Copy as cURL" action to recipe menu (<a href="https://github.com/LucasPickering/slumber/issues/123">#123</a>)</li>
<li>Add hotkeys to select different panes</li>
<li>Add pane for rendered request</li>
<li>Show response size in Response pane (<a href="https://github.com/LucasPickering/slumber/issues/129">#129</a>)</li>
</ul>
<h3 id="changed-25"><a class="header" href="#changed-25">Changed</a></h3>
<ul>
<li>Run prompts while rendering request URL/body to be copied</li>
<li>Improve UI design of profile pane</li>
<li>Show raw bytes for binary responses</li>
</ul>
<h3 id="fixed-28"><a class="header" href="#fixed-28">Fixed</a></h3>
<ul>
<li>Reset response body query when changing recipes (<a href="https://github.com/LucasPickering/slumber/issues/133">#133</a>)</li>
</ul>
<h2 id="0140---2024-03-18"><a class="header" href="#0140---2024-03-18">[0.14.0] - 2024-03-18</a></h2>
<h3 id="added-29"><a class="header" href="#added-29">Added</a></h3>
<ul>
<li>Add config option <code>ignore_certificate_hosts</code> (<a href="https://github.com/LucasPickering/slumber/issues/109">#109</a>)</li>
<li>Add menu action to open collection file in editor (<a href="https://github.com/LucasPickering/slumber/issues/105">#105</a>)</li>
<li>Add <code>authentication</code> field to request recipe (<a href="https://github.com/LucasPickering/slumber/issues/110">#110</a>)</li>
</ul>
<h3 id="fixed-29"><a class="header" href="#fixed-29">Fixed</a></h3>
<ul>
<li>Fix prompt in TUI always rendering as sensitive (<a href="https://github.com/LucasPickering/slumber/issues/108">#108</a>)</li>
<li>Fix content type identification for extended JSON MIME types (<a href="https://github.com/LucasPickering/slumber/issues/103">#103</a>)</li>
<li>Use named records in binary blobs in the local DB
<ul>
<li>This required wiping out existing binary blobs, meaning <strong>all request history and UI state will be lost on upgrade</strong></li>
</ul>
</li>
<li>Fix basic auth in Insomnia import</li>
</ul>
<h2 id="0131---2024-03-07"><a class="header" href="#0131---2024-03-07">[0.13.1] - 2024-03-07</a></h2>
<h3 id="changed-26"><a class="header" href="#changed-26">Changed</a></h3>
<ul>
<li>Move checkbox to left side of toggle tables</li>
</ul>
<h3 id="fixed-30"><a class="header" href="#fixed-30">Fixed</a></h3>
<ul>
<li>Fix scrolling on response body pane</li>
</ul>
<h2 id="0130---2024-02-21"><a class="header" href="#0130---2024-02-21">[0.13.0] - 2024-02-21</a></h2>
<h3 id="added-30"><a class="header" href="#added-30">Added</a></h3>
<ul>
<li>New informational flags to <code>slumber request</code>
<ul>
<li><code>--exit-status</code> to set exit code based on response status (<a href="https://github.com/LucasPickering/slumber/issues/97">#97</a>)</li>
<li><code>--status</code>, <code>--headers</code>, and <code>--no-body</code> to control printed output</li>
</ul>
</li>
<li>Filter response via JSONPath (<a href="https://github.com/LucasPickering/slumber/issues/78">#78</a>)</li>
</ul>
<h2 id="0121---2024-01-22"><a class="header" href="#0121---2024-01-22">[0.12.1] - 2024-01-22</a></h2>
<h3 id="changed-27"><a class="header" href="#changed-27">Changed</a></h3>
<ul>
<li>Improved styling of toggled table rows</li>
</ul>
<h2 id="0120---2024-01-07"><a class="header" href="#0120---2024-01-07">[0.12.0] - 2024-01-07</a></h2>
<h3 id="added-31"><a class="header" href="#added-31">Added</a></h3>
<ul>
<li>Move app-level configuration into a file (<a href="https://github.com/LucasPickering/slumber/issues/89">#89</a>)
<ul>
<li>Right now the only supported field is <code>preview_templates</code></li>
</ul>
</li>
<li>Toggle query parameters and headers in recipe pane (<a href="https://github.com/LucasPickering/slumber/issues/30">#30</a>)
<ul>
<li>You can easily enable/disable parameters and headers without having to modify the collection file now</li>
</ul>
</li>
<li>Add Copy URL action, to get the full URL that a request will generate (<a href="https://github.com/LucasPickering/slumber/issues/93">#93</a>)</li>
</ul>
<h3 id="changed-28"><a class="header" href="#changed-28">Changed</a></h3>
<ul>
<li>Show profile contents while in the profile list (<a href="https://github.com/LucasPickering/slumber/issues/26">#26</a>)</li>
<li>Remove settings modal in favor of the settings file
<ul>
<li>Supporting changing configuration values during a session adds a lot of complexity</li>
</ul>
</li>
</ul>
<h2 id="0110---2023-12-20"><a class="header" href="#0110---2023-12-20">[0.11.0] - 2023-12-20</a></h2>
<h3 id="added-32"><a class="header" href="#added-32">Added</a></h3>
<ul>
<li>Add action to copy entire request/response body (<a href="https://github.com/LucasPickering/slumber/issues/45">#74</a>)</li>
<li>Persist UI state between sessions (<a href="https://github.com/LucasPickering/slumber/issues/39">#39</a>)</li>
<li>Text window can be controlled with PgUp/PgDown/Home/End (<a href="https://github.com/LucasPickering/slumber/issues/77">#77</a>)</li>
<li>Add back manual reload keybinding (R)
<ul>
<li>Mostly for development purposes</li>
</ul>
</li>
<li>Add collection ID/path to help modal (<a href="https://github.com/LucasPickering/slumber/issues/59">#59</a>)
<ul>
<li>Also add collection ID to terminal title</li>
</ul>
</li>
<li>Add new docs for templates and collection reuse (<a href="https://github.com/LucasPickering/slumber/issues/67">#67</a>)</li>
</ul>
<h3 id="changed-29"><a class="header" href="#changed-29">Changed</a></h3>
<ul>
<li>[BREAKING] Key profiles/chains/requests by ID in collection file</li>
<li>[BREAKING] Merge request history into a single DB file
<ul>
<li>Request history (and UI state) will be lost</li>
</ul>
</li>
<li>[BREAKING] <code>show</code> subcommand now takes a <code>target</code> argument
<ul>
<li>Right now the only option is <code>slumber show dir</code>, which has the same behavior as the old <code>slumber show</code> (except now it prints the bare directory)</li>
</ul>
</li>
<li>[BREAKING] Remove option to toggle cursor capture
<ul>
<li>Turns out it's not that useful, since most terminals provide override behavior</li>
</ul>
</li>
<li>Filter request history by profile (<a href="https://github.com/LucasPickering/slumber/issues/74">#74</a>)</li>
<li>Hide sensitive chain values in preview</li>
<li>Change fullscreen keybinding from F11 to F
<ul>
<li>F11 in some cases is eaten by the IDE or OS, which is annoying</li>
</ul>
</li>
</ul>
<h3 id="fixed-31"><a class="header" href="#fixed-31">Fixed</a></h3>
<ul>
<li>Don't require collection file to be present for <code>show</code> subcommand (<a href="https://github.com/LucasPickering/slumber/issues/62">#62</a>)</li>
<li>Fix state file being created in root Slumber directory if collection file is invalid (<a href="https://github.com/LucasPickering/slumber/issues/71">#71</a>)</li>
<li>Fix pane cycling while in fullscreen (<a href="https://github.com/LucasPickering/slumber/issues/76">#76</a>)</li>
</ul>
<h2 id="090---2023-11-28"><a class="header" href="#090---2023-11-28">[0.9.0] - 2023-11-28</a></h2>
<h3 id="added-33"><a class="header" href="#added-33">Added</a></h3>
<ul>
<li>Add setting to toggle cursor capture</li>
<li>Add help modal</li>
<li>Add cursor navigation</li>
</ul>
<h3 id="changed-30"><a class="header" href="#changed-30">Changed</a></h3>
<ul>
<li>Always show help text in footer, regardless of notification state</li>
<li>Add highlight border to fullscreened pane</li>
<li>Allow exiting fullscreen mode with ESC</li>
</ul>
<h2 id="080---2023-11-21"><a class="header" href="#080---2023-11-21">[0.8.0] - 2023-11-21</a></h2>
<h3 id="added-34"><a class="header" href="#added-34">Added</a></h3>
<ul>
<li>Add <code>slumber show</code> subcommand</li>
</ul>
<h3 id="changed-31"><a class="header" href="#changed-31">Changed</a></h3>
<ul>
<li>Remove keybinding to reload collection
<ul>
<li>Not useful now that the TUI has automatic reloading</li>
</ul>
</li>
<li>Move to stable Rust channel and add MSRV of 1.74</li>
</ul>
<h3 id="fixed-32"><a class="header" href="#fixed-32">Fixed</a></h3>
<ul>
<li>Don't panic if the collection file is invalid on first startup <a href="https://github.com/LucasPickering/slumber/issues/34">#34</a>
<ul>
<li>The TUI will now show an empty screen, and watch the collection file for changes</li>
</ul>
</li>
<li>Fix long status code reasons getting cut off in response header <a href="https://github.com/LucasPickering/slumber/issues/40">#40</a></li>
<li>Trim leading/trailing newlines from header values to prevent validation error</li>
</ul>
<h2 id="070---2023-11-16"><a class="header" href="#070---2023-11-16">[0.7.0] - 2023-11-16</a></h2>
<h3 id="added-35"><a class="header" href="#added-35">Added</a></h3>
<ul>
<li>Added recursive templates for profile values, using the <code>!template</code> tag before a value</li>
</ul>
<h3 id="changed-32"><a class="header" href="#changed-32">Changed</a></h3>
<ul>
<li>Parse templates up front instead of during render</li>
<li>Switch to nom for template parsing
<ul>
<li>Parse errors should be better now</li>
</ul>
</li>
</ul>
<h2 id="060---2023-11-11"><a class="header" href="#060---2023-11-11">[0.6.0] - 2023-11-11</a></h2>
<h3 id="added-36"><a class="header" href="#added-36">Added</a></h3>
<ul>
<li>Add ability to preview template values. This will show the rendered value under current settings <a href="https://github.com/LucasPickering/slumber/issues/29">#29</a>
<ul>
<li>This includes a new modal to toggle the setting on/off, via the <code>X</code> key</li>
</ul>
</li>
<li>Add <code>command</code> source type for chained values, which uses stdout from an executed subprocess command <a href="https://github.com/LucasPickering/slumber/issues/31">#31</a></li>
</ul>
<h3 id="changed-33"><a class="header" href="#changed-33">Changed</a></h3>
<ul>
<li>HTTP method is now a plain string, not a template string. This simplifies some internal logic, and I don't think there was a compelling reason to make a template in the first place.</li>
</ul>
<h2 id="050---2023-11-07"><a class="header" href="#050---2023-11-07">[0.5.0] - 2023-11-07</a></h2>
<h3 id="added-37"><a class="header" href="#added-37">Added</a></h3>
<ul>
<li>Add top-level collection <code>id</code> field
<ul>
<li>Needed in order to give each collection its own history file</li>
</ul>
</li>
<li>Disable mouse capture to allow text highlighting <a href="https://github.com/LucasPickering/slumber/issues/17">#17</a></li>
<li>Add keybinding (F2) to send request from any view</li>
</ul>
<h3 id="fixed-33"><a class="header" href="#fixed-33">Fixed</a></h3>
<ul>
<li>Differentiate history between different collections <a href="https://github.com/LucasPickering/slumber/issues/10">#10</a></li>
<li>Ensure ctrl-c can't get eaten by text boxes (it guarantees exit now) <a href="https://github.com/LucasPickering/slumber/issues/18">#18</a></li>
</ul>
<h3 id="changed-34"><a class="header" href="#changed-34">Changed</a></h3>
<ul>
<li>Adjust size of profile list dynamically based on number of profiles</li>
<li>Use structured table display format for query parameters and headers</li>
<li>Tweak list and tab styling</li>
</ul>
<h2 id="040---2023-11-02"><a class="header" href="#040---2023-11-02">[0.4.0] - 2023-11-02</a></h2>
<h3 id="added-38"><a class="header" href="#added-38">Added</a></h3>
<ul>
<li>Request and response panes can now be fullscreened and scrolled <a href="https://github.com/LucasPickering/slumber/issues/14">#14</a></li>
</ul>
<h3 id="removed"><a class="header" href="#removed">Removed</a></h3>
<ul>
<li>Removed <code>Chain.name</code> field in config</li>
</ul>
<h3 id="changed-35"><a class="header" href="#changed-35">Changed</a></h3>
<ul>
<li>All modals now use a shared queue</li>
</ul>
<h3 id="fixed-34"><a class="header" href="#fixed-34">Fixed</a></h3>
<ul>
<li>Initially selected recipe loads most recent response <a href="https://github.com/LucasPickering/slumber/issues/13">#13</a></li>
</ul>
<h2 id="031---2023-10-22"><a class="header" href="#031---2023-10-22">[0.3.1] - 2023-10-22</a></h2>
<p>Initial distributed release!</p>

                    </main>
                </div>
            </div>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
