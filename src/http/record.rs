//! HTTP-related data types

use crate::{
    collection::{ProfileId, RecipeId},
    http::{ContentType, ResponseContent},
    util::ResultExt,
};
use anyhow::Context;
use bytes::Bytes;
use bytesize::ByteSize;
use chrono::{DateTime, Duration, Utc};
use derive_more::{Display, From};
use indexmap::IndexMap;
use reqwest::{
    header::{self, HeaderMap, HeaderValue},
    Method, StatusCode,
};
use serde::{Deserialize, Serialize};
use std::{
    fmt::{Debug, Write},
    sync::Arc,
};
use thiserror::Error;
use url::Url;
use uuid::Uuid;

/// An error that can occur while *building* a request
#[derive(Debug, Error)]
#[error("Error building request {id}")]
pub struct RequestBuildError {
    /// ID of the failed request
    pub id: RequestId,
    /// There are a lot of different possible error types, so storing an anyhow
    /// is easiest
    #[source]
    pub error: anyhow::Error,
}

/// An error that can occur during a request. This does *not* including building
/// errors.
#[derive(Debug, Error)]
#[error("Error executing request {}", "request.id")]
pub struct RequestError {
    #[source]
    pub error: reqwest::Error,
    /// The request that caused all this ruckus
    pub request: Arc<Request>,
    /// When was the request launched?
    pub start_time: DateTime<Utc>,
    /// When did the error occur?
    pub end_time: DateTime<Utc>,
}

/// Unique ID for a single launched request
#[derive(
    Copy, Clone, Debug, Display, Eq, Hash, PartialEq, Serialize, Deserialize,
)]
pub struct RequestId(pub Uuid);

impl RequestId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
}

impl Default for RequestId {
    fn default() -> Self {
        Self::new()
    }
}

/// A complete request+response pairing. This is generated by [HttpEngine::send]
/// when a response is received successfully for a sent request.
#[derive(Debug)]
pub struct RequestRecord {
    /// ID to uniquely refer to this record. Useful for historical records.
    pub id: RequestId,
    /// What we said. This has Arc to prevent cloning when the creator needs to
    /// hang onto it.
    pub request: Arc<Request>,
    // What we heard
    pub response: Response,
    /// When was the request sent to the server?
    pub start_time: DateTime<Utc>,
    /// When did we finish receiving the *entire* response?
    pub end_time: DateTime<Utc>,
}

impl RequestRecord {
    /// Get the elapsed time for this request
    pub fn duration(&self) -> Duration {
        self.end_time - self.start_time
    }
}

/// A single instance of an HTTP request. There are a few reasons we need this
/// in addition to [reqwest::Request]:
/// - It stores additional Slumber-specific metadata
/// - It is serializable/deserializable, for database access
///
/// This intentionally does *not* implement `Clone`, because each request is
/// unique.
#[derive(Debug, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq))]
pub struct Request {
    /// Unique ID for this request. Private to prevent mutation
    pub id: RequestId,
    /// The profile used to render this request (for historical context)
    pub profile_id: Option<ProfileId>,
    /// The recipe used to generate this request (for historical context)
    pub recipe_id: RecipeId,

    #[serde(with = "serde_method")]
    pub method: Method,
    /// URL, including query params/fragment
    pub url: Url,
    #[serde(with = "serde_header_map")]
    pub headers: HeaderMap,
    /// Body content as bytes. This should be decoded as needed
    pub body: Option<Bytes>,
}

impl Request {
    /// Generate a cURL command equivalent to this request
    ///
    /// This only fails if one of the headers or body is binary and can't be
    /// converted to UTF-8.
    pub fn to_curl(&self) -> anyhow::Result<String> {
        let mut buf = String::new();

        // These writes are all infallible because we're writing to a string,
        // but use ? because it's shorter than unwrap().
        let method = &self.method;
        let url = &self.url;
        write!(&mut buf, "curl -X{method} --url '{url}'")?;

        for (header, value) in &self.headers {
            let value =
                value.to_str().context("Error decoding header value")?;
            write!(&mut buf, " --header '{header}: {value}'")?;
        }

        if let Some(body) = &self.body_str()? {
            write!(&mut buf, " --data '{body}'")?;
        }

        Ok(buf)
    }

    /// Get the body of the request, decoded as UTF-8. Returns an error if the
    /// body isn't valid UTF-8.
    pub fn body_str(&self) -> anyhow::Result<Option<&str>> {
        if let Some(body) = &self.body {
            Ok(Some(
                std::str::from_utf8(body).context("Error decoding body")?,
            ))
        } else {
            Ok(None)
        }
    }
}

/// A resolved HTTP response, with all content loaded and ready to be displayed
/// to the user. A simpler alternative to [reqwest::Response], because there's
/// no way to access all resolved data on that type at once. Resolving the
/// response body requires moving the response.
#[derive(Debug, Serialize, Deserialize)]
pub struct Response {
    #[serde(with = "serde_status_code")]
    pub status: StatusCode,
    #[serde(with = "serde_header_map")]
    pub headers: HeaderMap,
    pub body: Body,
}

impl Response {
    /// Parse the body of this response, based on its `content-type` header
    pub fn parse_body(&self) -> anyhow::Result<Box<dyn ResponseContent>> {
        ContentType::parse_response(self)
            .context("Error parsing response body")
            .traced()
    }

    /// Get the value of the `content-type` header
    pub fn content_type(&self) -> Option<&[u8]> {
        self.headers
            .get(header::CONTENT_TYPE)
            .map(HeaderValue::as_bytes)
    }

    /// Make the response body pretty, if possible. This fails if the response
    /// has an unknown content-type, or if the body doesn't parse according to
    /// the content-type.
    pub fn prettify_body(&self) -> anyhow::Result<String> {
        Ok(self.parse_body()?.prettify())
    }
}

/// HTTP response body. Content is stored as bytes to support non-text content.
/// Should be converted to text only as needed
#[derive(Default, From, Serialize, Deserialize)]
pub struct Body(Bytes);

impl Body {
    pub fn new(bytes: Bytes) -> Self {
        Self(bytes)
    }

    /// Raw content bytes
    pub fn bytes(&self) -> &[u8] {
        &self.0
    }

    /// Owned raw content bytes
    pub fn into_bytes(self) -> Vec<u8> {
        self.0.into()
    }

    /// Get bytes as text, if valid UTF-8
    pub fn text(&self) -> Option<&str> {
        std::str::from_utf8(&self.0).ok()
    }

    /// Get body size, in bytes
    pub fn size(&self) -> ByteSize {
        ByteSize(self.bytes().len() as u64)
    }
}

#[cfg(test)]
impl From<String> for Body {
    fn from(value: String) -> Self {
        Self(value.into())
    }
}

#[cfg(test)]
impl From<&str> for Body {
    fn from(value: &str) -> Self {
        value.to_owned().into()
    }
}

impl Debug for Body {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // Don't print the actual body because it could be huge
        f.debug_tuple("Body")
            .field(&format!("<{} bytes>", self.0.len()))
            .finish()
    }
}

/// Serialization/deserialization for [reqwest::Method]
mod serde_method {
    use super::*;
    use serde::{de, Deserializer, Serializer};

    pub fn serialize<S>(
        method: &Method,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(method.as_str())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Method, D::Error>
    where
        D: Deserializer<'de>,
    {
        <&str>::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

/// Serialization/deserialization for [reqwest::HeaderMap]
mod serde_header_map {
    use super::*;
    use reqwest::header::{HeaderName, HeaderValue};
    use serde::{de, Deserializer, Serializer};

    pub fn serialize<S>(
        headers: &HeaderMap,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // HeaderValue -> str is fallible, so we'll serialize as bytes instead
        <IndexMap<&str, &[u8]>>::serialize(
            &headers
                .into_iter()
                .map(|(k, v)| (k.as_str(), v.as_bytes()))
                .collect(),
            serializer,
        )
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<HeaderMap, D::Error>
    where
        D: Deserializer<'de>,
    {
        <IndexMap<String, Vec<u8>>>::deserialize(deserializer)?
            .into_iter()
            .map::<Result<(HeaderName, HeaderValue), _>, _>(|(k, v)| {
                // Fallibly map each key and value to header types
                Ok((
                    k.try_into().map_err(de::Error::custom)?,
                    v.try_into().map_err(de::Error::custom)?,
                ))
            })
            .collect()
    }
}

/// Serialization/deserialization for [reqwest::StatusCode]
mod serde_status_code {
    use super::*;
    use serde::{de, Deserializer, Serializer};

    pub fn serialize<S>(
        status_code: &StatusCode,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_u16(status_code.as_u16())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<StatusCode, D::Error>
    where
        D: Deserializer<'de>,
    {
        StatusCode::from_u16(u16::deserialize(deserializer)?)
            .map_err(de::Error::custom)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_util::*;
    use factori::create;
    use indexmap::indexmap;
    use serde_json::json;

    #[test]
    fn test_to_curl() {
        let headers = indexmap! {
            "accept" => "application/json",
            "content-type" => "application/json",
        };
        let body = json!({"data": "value"});
        let request = create!(
            Request,
            method: Method::DELETE,
            headers: header_map(headers),
            body: Some(serde_json::to_vec(&body).unwrap().into()),
        );

        assert_eq!(
            request.to_curl().unwrap(),
            "curl -XDELETE --url 'http://localhost/url' \
            --header 'accept: application/json' \
            --header 'content-type: application/json' \
            --data '{\"data\":\"value\"}'"
        );
    }
}
